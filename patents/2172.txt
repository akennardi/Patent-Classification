ABSTRACT.
 This is an application software which allows users to make more accurate
decisions when selecting the correct treatment type, correct dosage and correctly
predicting recovery time based on past statistics. This system also let the patient
to prioritize his own recovery requirements, (less painful, time taken etc.) and
make treatment selection based on those requirements. Since the database is
sharing globally users from multiple location can share their data and knowledge.
They can make collaborative decisions when they change weights or add new
factors or filter out some factors.
This system basically running from two layers namely main grid spaces and child
grid spaces. Since system may not have data to fill the full areas of both these
layers, system use multi-variable gradient descend along with Monte Carlo
Stimulation to fill these gabs. Gradient descend is running interactively between
these two layers. When some part of empty space is filled in a one layer, it
might automatically fill data in the other layer's empty spaces. Or it may
generate data sufficient to establish minimum maximum data of the gradient
descend of that layer. So this interactive data filling happens until system can no
longer will empty spaces.
After filling maximum empty spaces system use several ways of clustering
methods to find values of the new data point. Here new patients record we
consider as the new data point. Our goal is to find the best treatment, best
dosage and expected recovery time for the new patient. Before establishing
clusters, for each grid cell in the main grid space we find the best treatment type
using the algorithm given above. Then grid cells with same best treatment type
adjacent to each other and if they are continuous in any direction they come
under same cluster. If the new point point is fallen inside one of these clusters,
system use gradient descend to find the best treatment type and dosage. It uses
the child grid space layer data of the poly data points of that cluster and make
predictions. If those clusters does not hold sufficient data densities and no other
best treatment type data in between clusters, system try to establish gradient
descend maximum and minimum data along with other clusters and find values
based on that gradient descend. If new data point is fallen outside of any of
those clusters we use self tuning spectral clustering to build clusters. Here we
could adjust number of clusters so that we could bring the new data point under
one of those clusters. Or we could use gravitational attraction to find the best
treatment type.
To find the severity of symptoms we use severity index and to define how critical
to the health of the patient this severity we use criticality index. To define
minimum data requirements for each of these symptoms we use data density
index.
                                            1

Background of the invention
Here I am proposing an application software where system can use past
statistical data to predict the best treatment type, expected improvements with
each treatment type, the best dosages of drugs, and the best treatment
combinations. This application software also generates a report which can be
used to monitor a patent's improvement. This report predicts the improvements
that are supposed to be achieved with the given treatment, and within a given
time. Here our system uses a double layer system which comprises of a series of
main multi-variable grids and a series of child multi-variable grids for each of
those main grids, to make predictions. Here we use multi-variable gradient
descend to find the data for unknown areas and use Monte Carlo stimulation to
fill these empty spaces. Since we are storing all data in a centralized cloud
based database, this database can be shared by multiple locations. Physicians
can adjust weights collaboratively to make more accurate decisions. Goal of this
application software is to make maximum use of available data and to make
more accurate decisions, based on those data and shared knowledge.
Alternative ways of achieving same functionality.
  Instead of multivariate gradient descend we could use cross-co-variance or
cross-correlation interactively to generate same results.
Other applications where we could use same concept.
 We could use the same concept in myriad of other applications where we need
to make more accurate predictions based on available data.
                                           2

                                                                             * Here weight change includes
                                                                            both severity detection weights
                                                                            and output dimentions weights.
                                                                           * Any weight changes requires
                                                                           most of the processed values to be
                                    1                                      recalculated.
                        Physician enter             Systemn gather alll(2)
                        Factor readings,     -     data relevant to
                       diagnosis, seveity          those symptoms                             Patient select
                                                                                         -   own output            ye
                                                            variables                                  weight?
Reading                                           System find the                     No
                         Compare physician        most suitable
correction               Diagnosis with           treatment &
Needed                                                output      minimumYhits
                              Syste
                                  findingsTmpray
                                                                                                           djs
                                                     hysicians                             Temporary adjust
                                                                                              tput variable
                         Evaluate the              Collaboratively                         weights to find best
                                                   Try to match the                        treatment based on
                                                                                           patient requirements
                                                       Deitio
                     and          g
                                                               requiredehead
                                                              Will changing
                                                                                                      Wegh offcoso
                                                     ,weight       or adding
                                                                             wo k
                                                                  feature
                                                     < a new
                                            DeviationdiagnosisoYes
                 Addaneror acor            No                  If minimum         Yes                 Either change
           erro datarcrdn                                      required heads             _4          Weight of factors or.
                        errordataapproved
                                                                                                      add new factors
                                                                                                          Record adjustme-nts"
                                                                                                          & new factors
                                                                                                          values for future
                                                                                                          diagnosis
                                            Fig A01

    TITLE: Statistics based software system for finding the best
                                treatment type and
 predicting the improvement, generating live monitoring reports.
           INVENTOR: SUDESHINIE PIUMIKA WARNAKULASOORIYA
                         Background of the invention
Here I am proposing an application software where system can use past
statistical data to predict best treatment type, expected improvements with each
treatments type, Best dosage and best treatment combinations. This application
software also generate a report which can be use to monitor patent's
improvements. This report predict the improvements supposed to be achieved
with the given treatment and within a given time. System use a double layer
system which comprise from a series of a main multi-variable grid and a series of
child multi-variable grid for each of those main grids, to make predictions. Here
we use multi variable gradient descend to find data for unknown areas and use
Monte Carlo stimulation to fill these empty spaces. Since we are storing all data
in a centralised cloud based database this database can be shared by multiple
locations. Physicians can adjust weights collaboratively to make more accurate
decisions. Goal of this application software is to make maximum use of available
data and make more accurate decisions based on those data and shared
knowledge.
Brief Description
[0001] All patients diagnosis data is a massive records set and quite
cumbersome for the calculation. First step is to reduce large records set to an
average value so that calculations will be easier and faster. How much we need
to reduce the data is a matter of how many records we have in our hand
                                           1

and how sensitive these data are. For this purpose we build an index called data density index.
Basically data density index defines how much data densities are required for each symptom.
Any deviation from healthy status we consider as a symptom. Our system is a treatment oriented
system.
  [0002] Next we have an index called criticality index. This index gives us a value for the criticality
of each possible deviation from the healthy status. Criticality Index defines the criticality at the each
level of deviation from the healthy status, means how critical it can be to the health of a patient. For
each symptom we have to maintain a range of different criticality values based on how severe the
symptom are. The criticality index is not using a unique unit values for criticality values for each
symptom. Its unit value common across all symptoms.
 [0003] Apart from criticality index we also need to maintain another index called severity index.
Severity index defines how much deviated from healthy status. Meaning the severity of the
particular symptom. Since its not practical to enter criticality index data for each deviation we could
also use gradient descend to find data based on several previously entered data.
[0004] Improvement marker value is calculated based on the overall improvement. Any positive
improvement will increase this value and any side effects will decrees this value. This value is based
on severity index and how much severity is being changed by each treatment. For one particular
treatment if child grid output variables show a positive value it will increase this improvement
marker value. For one particular treatment if it has some negative child grid output variables it will
decrease this value.
[0005] Each data points in the multidimensional space is associated with a severity index reduction
values for all types deviation from healthy status. (More details will be provided in following

sections).They are called child grid space output variables. Main grid location within multi-variable
space show the parameters of the patient. Any one particular deviation from healthy system is called
a symptom. All these deviations are becoming different clustering processes.
Following bulletin points are repeated for each symptom specific clustering process.
[0006] If the number of data points are extremely dense we can reduce data points to make the
calculation faster. After deciding the density index next step is to reduce number of data points. If
we only need Z number of records ; total number of poly data points clusters = total number of
records /Z. Poly data point clusters means data clusters residing inside main grid cells (see. [0007]).
Then we assign the median value(severity index reduction value) to the central point of that cluster.
This new central point becomes the new data point.
[0007] Data space is divided in to a unit based grid. Then the average total improvement of each
treatment is calculated and the treatment of highest severity reduction index value inserted in to the
each grid point. If we got sufficient data to cover the full spectrum, Adjacent continuous same
treatment grid points become new clusters. If new point is belongs to a cluster where required
number of data points threshold not met we execute [0008].
[0008] If required number of minimum data points threshold is not met system starts calculating the
central point of the nearby clusters and their average weight. Then starts checking the gravitation
attraction to each of these clusters. Highest attractive clusters (representing one treatment) treatment
is chosen.
[0009] If the new data point is fallen inside a cluster multivariate gradient decent is used within
that cluster to calculate 'improvement marker value' for the new data point.

[0010] If the new data point is fallen outside a cluster certain distance radius (including that cluster
) is selected to calculate the gradient descend . Here even though clusters are not connected it should
be within available values for minimum and maximum range of a gradient descend. Any other
treatment type should not be present in between.
[0011] Treatment might have different input variables. For example dose might be different from
one patient to the other. In this case we can have a range of main grid spaces to represent those
data. We could build a gradient descent chart after taking data from one specific location from all of
these main grids of that range. Then we could fill missing data using gradient descend. We could do
this for all poly data points. Or else we could use this as another parameter within output gradient
space. Or else we could apply cross- covariance as well.
[0012] Similarly output type also might have multiple variables. For example patient improvement
might come as how quickly the patient make the total recovery, How less painful, or even some
symptoms not fully recovering as well . We use multivariate child grid space gradient descend to
find the improvement percentage of each of these factors. We also maintain a look up table for
giving a weight to each of these output variable. These weights are unique to each symptom. Then
we multiply each of these weight along with each output variable values and sum up together to
generate total improvement of that particular treatment for that symptom.
[0013] Loop ends here.
[0014] Then we can calculate the overall improvement marker. All positive 'severity reduction
index value's will increase this value. Any negative value's will decrease this value.

Detailed explanation along with drawings
[0015] Figure A01
  Figure AO 1 shows the flow of the system. The system collects data from all possible sources and after
feeding new patient's records the to the system, system undergoes the processes explain in the coming
section. and suggest the best possible treatment.
At the Step 4 system do a comparison to identify the level of deviation of system recomended treatments and
physician recomonded treatments.s
At the Step 7 If previously detected daviation is a major deviation, physicians are collaboratively allowed to
either change the weights of the exising factors or to add a new factor and match system recomended
treatments with physician recomemnded treatments.
If system has already collected data for the new factor it will be incorparated to the main grid as one of its
parameters.
At the step 6 System will use this new weights for future diagnosis and if it is a new factor system will start
collecting those data and once minimum required number of records are collected this factor will be used for
the future treatment recomendations as well.
At the step 2i patent can select patient's own priorities (output variables weight) and select the best treatments
based on patient's requirements.
At the step 9 if system still unable to match system recomended treatment with physician recomended
treatment, system add a error factor and start collecting data for the error factor. Error factor is the deviation
value. This error factor is used to adjust the predicted values in the future.
[0016] Figure A02
  Figure A02 illustrates an interface which is related to the step 8 of the figure 1. After required number of

physicians approval, physicals are allowed to change both severity checks weights and output variables
weight. When the user enter new patients readings user also allowed to change output variables weights
temporary, so that the system can generate best treatment based on user preferences as well.
[00171 Figure A03
 Figure A03 Is the most important and the heart of the application. This system comprise from a large
number of main grid gradient descend charts and child gradient descend charts for each grid point wihin that
main grids. When data not available for some areas in these charts system use multi variable graient descend
and try to fill empty spaces interactively. If these data empty areas are not within minimum and maximum of
a known gradient descend , We cannot use gradient descend to find values for empty spaces .But since these
interactive filling will be going on between child and main grids interactively until system can no longer fill
empty spaces (until convergence), at some point there is a chance to get these empty spaces filled. Once we
have established the gradient descend of an area we use the Monte calco stimulation to fill data within that
area. When system found interactively running gradient descend ,system will not add any more data points to
the system we consider system has reached its convergence. After reaching convergence we can run re
clustering and adjust the number of cluster level dynamically to bring new data point under one of those
clusters . At this point we check the cluster which this data point fall under have sufficient points required
according to the density index. If yes we can use gradient desecnt or appropriate method as mentioned before
[0008],[0009],[0010].
[0018] Figure A04
   If output variables in the child grid space includes time as a factor system can generate time specific
improvement predictions. Any deviation might requires either weight change or add of a new factor as shown
in the figure 01. If still cannot match with actual improvement with system recomended improvement we
might need to add error deviation factors for each of these output variables. We can use these values for future
prediction adjustments.

[0019] Figure A05
 Shows a report compraing improvement predicted by the system and actual improvement results.
[0020] Figure B01
   Shows the benchmark line which the system is using for ditecting a particular symptom. Dots represents
readings from separate patients. Shortest distance from the benchmark line to individual dots represents the
severity of the symptom of that particular patient. (3) Represents the area where that symptom is not
present. We isolate factors which are only relevent to the diognosed symptom and finding its severity. We
will assign relevent weight to each of those factors and then will find the shortest distance from Benchmark
line. Benchmark line is the broundry line for identyfying that disease.
Disease benchmark is a continuous line which depends on one or more factors.Related factor values needed
to be entered by thse user. By entering more values for each point granuality will be higher and system will
generate more precise calculations. We could use monte carlo stimulation to genarate data in between these
values using gradient descend to make it a single continous line.
[0021] Figure B02.
  shows how do we implements elimination criterias within the gaussian model. we use grey clusters for this
purpose. Grey clusters comprises from areas where it is impossible to present that symptom or which comes
under different symptom , Still the patients have shown some symptoms of that disease. Emperical analysis
and some other proven theories may suggest some regions within the gaussian are impossible areas to present
that particular disease. We call them as grey areas. Grey areas means this symptomis not probable even
though some similar values are present for those parameters (factors). Grey area values needed to be entered
by thse user. By entering more values for each point granuality will be higher and system will generate more
precise calculations.We could use monte carlo stimulation to genarate data in between these values using
gradient descend to make it a bountry well defined area..

[0022] Figure B03
 Illustrates how individual factor's unit sizes are adjusted (normalized) to give a meaningful benchmark line.
These unit sizes are adjusted based on the severity check factor adjustment weights.
[0023] Figure 01
 (1) shows a grid element which has three data points. This grid shows data points only related to the
treatment type 01. Even though for the representative purposes we shown them as single individual
data points it actually represents several series of data mapped against a Multi -dimensional
Cartesian space. These multi-dimensional data stored inside grid elements are called Child Multi
Dimensional Grid Spaces (CMDGS). Since Main grid space also a unit based division of a multi
dimensional Cartesian Space we call it the Main Multi Dimensional Grid Space (MMDGS) . Since
these data points (3) represents series of data in a another multi dimensional Cartesian space we call
them poly data points.
 (2) When we have highly dense poly data points inside a grid entry of the MMDG space we pick up
all poly data points residing within that particular grid entry and average them inside the CMDG
space as shown in the (4). Then we create a new one poly data point for that particular grid entry.
We could also reduce the number of poly data points residing within a grid entry instead of setting it
to one. This will significantly reduce the time taken to converge the whole data space.
(5)(6) Are dimensions in CMDG space. We call them as output variables. 01,02,03 represents
improvement related output variables mapped against dosage representing dimension(6). These
improvement dimensions could represents bath positive and negative improvements.

           max
                  w15
                    01 I  1
                            +
                               02
                                  55
                                   i 2
                                       +w15
                                         03 i   3
                                                  +.............
            i-min
[0024] Figure 02
Figure 2 represents a same data set, But for a different treatment.
Here W represents the weight relevant to that particular output variable.
[0025] Figure 03
Figure 03 shows how to find the best possible treatment type for a grid entry. It also calculate the
best possible improvement level could achieve within that grid entry by that particular treatment.
System starts reading dosage and improvements from minimum unit level to the maximum unit level
(acceptable limit) or from minimum level to the converges (No more improvement, even though
dosage was increased.) of all output variables.
   Repeat for all treatment types.
          Repeat from minimum dosage to maximum dosage
                  If Previous-highest improvement < CurrentHighest-improvement
                    Previous highest-improvement = CurrentHighest-improvement
                   End If
          End repeat
        Select the treatment type with highest improvement to that particular grid entry.
   End repeat

[0026] Figure 04
  Figure 04 shows how to establish clusters inside the MMDG space. If any two grid entries with
same best treatment type are located to each other in any dimensional direction they comes under the
same cluster.
[0027] Figure 051
This figure shows how to fill an empty grid entry within a cluster. (6) shows an empty grid entry
within cluster C3. (1) shows CMDG spaces for poly data point (4). (2) shows CMDG spaces for
poly data point (5). *,# etc. are symbols used to show that each of these clusters have different best
treatment types. Here we presume that all CMDG spaces are filled with sufficient data to cover the
full spectrum.
    Repeat for all poly data points within that cluster except empty ones.(step 01)
      Repeat for all CMDG spaces within that poly data point. (step 02)
        Repeat for all possible child grid entry values within that CMDG space.(Ex X1,X2)(step 03)
                     For each of these child grid entry we create an empty MMDG space.(step 04)
                    We map child grid entry values to relevant MMDG space main grid entry where
                     we read the poly data point.(step 05)
                     We run multi-variable gradient to fill empty points within MMDG space.
                     (step 06)
                       ((8),(1 1) are examples of such empty spaces created within MMDG space
                      due to the missing poly data point(6)).
                      Each of this step execution will generate a child grid entry value for the
                      empty poly data point.
           End Repeat
        End Repeat
    End Repeat
(13) is a new poly data point generated by the system. After running multi-variable gradient decent

(MVGD) on (8) we retrieved 01Y1 value on (13). Similarly after running multi-variable gradient
decent on (11) we retrieved 01Y2 value on (13). There is a missing value (14) within new poly data
CMDG space. This is generally due to the fact that by running MVGD at step 06 system could not
generate a value because there were no sufficient data to run MVGD. By running MVGD at
CMDG space level we can fill some of these missing data.
[0028] Figure 05.
 Here steps are very much similar to what we show in Figure 5i. Here instead of retrieving cluster
wise data we retrieve data from whole or large part of the MMDG space for a one particular
treatment type. Poly data point 4 with a small dot denotes it has not filled with sufficient data to
cover the full spectrum of the CMDG space. Poly data point 5 with a large dot denotes it has filled
with sufficient data to cover the full spectrum of the CMDG space. Using similar steps as in figure
05 we can fill some of empty space data in the CMDG space, Since it cover more area in the
MIMDG space. But the trade off here is more execution time.
[0029] Figure 06.
  This diagram shows a MVGD chart generated during the process shown on figure 05i for the
output variable 02.
[0030] Figure 06i.
  This diagram shows a MVGD charts generated during the process shown on figure 05i. But Here
as you can see CMDG space has more than two variable. Here the third dimension is the time taken
for the improvement. As mention before CMDG space is also a multi dimensional space. So
CMDG space can have any number of dimensions with associated weight factor.

[0031] Figure 07
 Figure shows which gradient descent data we can use for the empty space filling in MVGD charts
and which gradient descent charts we cannot. For example we cannot use gradient descent (7) to fill
the empty space (2). They are not within same gradient descent level. We use maximum and
minimum convergence points to check whether these empty spaces are fallen within that range
before running gradient descent to generate new values to fill the void. (2) empty space falls within
gradient descent (8) and its within minimum maximum convergence points of the gradient descent
(08). (13) shows a sample convergence point.
[0032] Figure 08
 Figure shows how MVGD charts and their respective CMDG spaces are interactively filling empty
spaces of each other until full space data convergence or no more filling of data.
[0033] Figure 09
(1),(2),(3) shows CMDG space charts for treatment type A. (4),(5),(6) shows CMDG space charts
for treatment type B. (7),(8),(9) shows after giving treatment (AB) as a combination what going to
be the result and what will be the output if will add expected improvement of treatment A
improvement and expected improvement treatment B. (10),(11),(12) shows the difference between
these two values for respective charts. (13),(14),(15) shows new charts generated after mapping
these difference values. We consider these charts as a new CMDG spaces and use to generate
MVGD charts and use them interactively fill empty spaces as shown in figure 08. These charts are
called combinatory error charts. We use these charts to fill empty spaces of treatment A,B,AB
interactively. Also note we may use more than two treatment combinations data and its result to fill

these empty spaces as well. Here we use bottom-to- top approach to find differences values, similar
to what we did with two combinations.
[0034] Figure 10
 This figure shows how to use the Monte Carlo stimulation to fill data in the low density areas or
empty areas. Apart from the data that we generate to specific location within the poly data CMDG
spaces or MVGD charts. We can use Monte Carlo stimulation to generate data to cover a large area.
When we run the Multi variable gradient descent we find the theta values specific to each
dimensions. We can use these values along with Monte Carlo stimulation to generate these synthetic
data. (8) and (9) shows minimum and maximum convergence points found by gradient descent. If
either new points are outside within this range or we don't have sufficient data to establish the
gradient descent patter, we would not generate any synthetic data within these spaces.
[0035] Figure 11
                                       F      =G*m *m
                                                         1     2
                                                       2
                                                     D
  This figure shows a MMDG space where sufficient data are not available to cover the full main
grid space. Imagine if the new data point is falling outside of any of the clusters or clusters are too
small to run MVGD. Since we have already filled empty spaces where we could generate synthetic
data with gradient descent or with any other means, remaining empty areas are mostly unknown
areas. Here we apply the gravitational attraction concept to find the best suitable treatments.

First we run one of the available clustering algorithms. Poly data points with highest improvement
for same treatment type will bring them together. Spectral clustering with self tuning is an ideal
algorithm to run here. Sometimes we may have to break some clusters outside the algorithm since
poly data points with highest improvement for different treatment type could come under same
cluster.
  Repeat for all clusters.(step 01)
               get all poly data points within that cluster except empty ones.(step 02)
             Retrieve the highest possible improvement value that poly data point.(step 03)
             Find the medoid of the current cluster.(step 04)
             Sum up all highest possible improvement values for all poly data points within current
             cluster.(step 05)
             Assign a constant value to the new data point since its not going to be change for
             different clusters.(step 06)
             Apply the above algorithm to find the attraction of the current cluster to the new data
              point.
              M1 will be the value obtained by step 5. M2 is the constant weight value given to the
              new data point. D is the distance between current cluster medoid and and the new
              data point.
   End Repeat
  We can find the most attractive cluster to the new data point. This way we could find the best

possible treatment type.
[0036] Figure 12
  This figure shows if the system user wants to give an average value to a particular area in the
output variables of the CMDG space, how the system going to achieve it. User could also spacify the
density of data for that particular area.
   For the simplicity of the explanation we confine number of output variables to two.
     XO to X1 is the range where we want to apply the given average value. Y2 is same as given
average value. Y1 is equal to y2 + (y2-y3). X1 is the middle point between XO and X2. For chart (6),
if we don't know the values from (4) to (5). We run the gradient descent and establish
  that remaining part's data by using Monte Carlo Stimulation. Now we want to maintain the current
gradient descent while not losing new average value. If chart line (6) and (7) cut each other that
means we could do more adjustments to new data points, So that they would align more closely
while not loosing its average value. (2) (3) arrows shows such adjustments. We could run error cost
function to find the new gradient descent, or to make some data adjustments here.
 [0037] Alternative ways of achieving same functionality
Instead of multivariate gradient descend we could use cross-co-variance or cross-correlation
interactively to generate same results.
[0038] Other applications where we could use same concept.
We could use the same concept in myriad of other applications where we need to make more
accurate predictions based on available data.

[0039] ABSTRACT
 This is an application software which allows users to make more accurate decisions when selecting
the correct treatment type, correct dosage and correctly predicting recovery time based on past
statistics. This system also let the patient to prioritise his own recovery requirements (less painful,
time taken etc.) and make treatment selection based on those requirements. Since the database is
sharing globally users from multiple location can share their data and knowledge. They can
collaborative make decisions when they change weights or add new factors or filter out some factors.
This system basically running from two layers namely main grid spaces and child grid spaces. Since
system may not have data to fill the full areas of both these layers, system use multi-variable
gradient descend along with Monte Carlo Stimulation to fill these gabs. Gradient descend is running
interactively between these two layers. When some part of empty space is filled in a one layer, it
might automatically fill data in the other layer's empty spaces. Or it may generate data sufficient to
establish minimum maximum data of the gradient descend of that layer. So this interactive data
filling happens until system can no longer will empty spaces. After filling maximum empty spaces
system use several ways of clustering methods to find values of the new data point. Here new
patients record we consider as the new data point. Our goal is to find the best treatment, best dosage
and expected recovery time for the new patient. Before establishing clusters, for each grid cell in the
main grid space we find the best treatment type using the algorithm given above. Then grid cells
with same best treatment type adjacent to each other and if they are continuous in any direction they
comes under same cluster. If the new point point is fallen inside one of these clusters, system use
gradient descend to find the best treatment type and dosage. It uses the child grid space layer data of
the poly data points of that cluster and make predictions. If those clusters does not hold sufficient

data densities and no other best treatment type data in between clusters, system try to establish
gradient descend maximum and minimum data along with other clusters and find values based on
that gradient descend. If new data point is fallen outside of any of those clusters we use self tuning
spectral clustering to build clusters. Here we could adjust number of clusters so that we could bring
the new data point under one of those clusters. Or we could use gravitational attraction to find the
best treatment type. To find the severity of symptoms we use severity index and to define how
critical to the health of the patient this severity we use criticality index. To define minimum data
requirements for each of these symptoms we use data density index.
 References
Lihi Zelnik-Manor and Pietro Perona ,"Self-tuning spectral clustering", in Advances in Neural Information
Processing Systems, volume 17,pp.1601-1608. MIT Press, (2004).

Claims:
1. For each existing treatment type for one particular disease, picking of all the
relevant improvements, all the side affects of those treatment aspects, the error
factors due to the physician's with the system decision mismatch, and the
treatment dosages (including treatment with a single drug or a method, or
combinations of either) as output variables, and all the other variables as input
variables, in order to map to two different Multi Dimensional (multi-variable) grid
Spaces, and for each point in the output variables' space (CMDG space),
creating a full input variable multi dimensional Cartesian space (MMDG space),
so that they could interactively fill each others unknown blank values in their grid
spaces until they reach to the convergence.
2. According to claim 1, the use of 'Multi Variable Gradient Descend' to find more
data for unknown areas, and the use of 'Monte Carlo Stimulation' when filling
blank values, and finding the maximum and minimum values possible according
to 'Multi Variable Gradient Descend' with Monte Carlo Stimulation, in order to
assure filled values within that range.
3 After completion of the steps in claim 2, Multiplication of respective weights
assigned to each improvement type along with its value, and addition of them
together for each treatment, to find the best treatment type for each data point in
the MMDG space.
4 After finding the best treatment type for each data point in the MMDG space
according to claim 3, building clusters so that close proximity values comes
under the same cluster, and if a new values sits inside a cluster picking that
value into that specific cluster, or if it's sitting outside all clusters within a
maximum and minimum value range for a Monte Carlo Stimulation trend (Multi
Variable Gradient Descend) of a cluster, generating its value and finding the
cluster to which it belongs to, based on that value, or if it's sitting outside of any
of those clusters, using gravitational attraction to find the closest cluster.
5 Maintaining a global criticality index and a severity index for each symptom,
and also the Grey-area records and the benchmark line within the Cartesian
space for each disease, and multi variable gradient descend with Monte Carlo
stimulation to fill these blank spaces in the above mentioned data-spaces, when
in circumstances of insufficient data availability.
                                               1

2
                 Editorial Note
<removed-date>
                   <removed-apn>
              There are 23 pages of drawings only
<removed-apn>

<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
