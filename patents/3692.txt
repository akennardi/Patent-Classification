                                         ABSTRACT
  One embodiment of the present invention includes an approach for efficient start-up for
  secured connections and related services. A client machine receives, via an application
  program, a request to send a secure message to a server machine. The client machine
5 transmits a plurality of messages to the server machine that includes a first message
  comprising at least two of user authentication data, entity authentication data, key
  exchange data, and encrypted message data. The client machine receives, from the
  server machine, a second message that includes a first master token comprising a first
  set of session keys for encrypting and authenticating messages exchanged with the
0 server machine.

          EFFICIENT START-UP FOR SECURED CONNECTIONS AND RELATED
                                            SERVICES
   CROSS-REFERENCE TO RELATED APPLICATIONS
   [0001]     This application claims the benefit of the United States provisional patent
 5 application titled, "MESSAGE SECURITY LAYER FOR COMMUNICATIONS OVER A
   NETWORK," filed on October 24, 2014 and having Serial No. 62/068,504 and United
   States patent application titled, "EFFICIENT START-UP FOR SECURED
   CONNECTIONS AND RELATED SERVICES," filed October 22, 2015 and having
   Serial No. 14/920,641. The subject matter of these related applications is hereby
10 incorporated herein by reference.
   BACKGROUND OF THE INVENTION
   Field of the Invention
   [0002]      Embodiments of the present invention relate generally to computer security
   and, more particularly, to efficient start-up for secured connections and related
15 services.
   Description of the Related Art
   [0003]      Machines within a computer network typically employ various techniques to
   exchange secure messages when those machines communicate with one another in
   an effort to prevent third-parties from reading or tampering with the exchanged
20 messages and potentially engaging in illegal or undesirable activities such as identity
   theft, corporate espionage, or stealing or compromising services. Conventional
   techniques to secure computer communications usually include mechanisms that
   ensure that a given received message originated from an appropriate machine within
   the computer network and that the content associated with a given received message
25 was not tampered with or marginalized after being transmitted by an appropriate
   machine within the computer network.
   [0004]      Exemplary approaches for exchanging secure messages include Transport
   Layer Security (TLS) and predecessor Secure Sockets Layer (SSL). TSL and SSL
   are cryptographic protocols designed to provide communications security over a
30 computer network for various purposes, including web browsing, email, Internet
   faxing, instant messaging, and voice-over-IP (VoIP). In general, TLS and SSL can be
   used to secure all communications between server machines offering various online

   services and client machines that access such online services. The TLS and SSL
   protocols provide privacy and data integrity during message exchange between two
   or more communicating computer applications executing on two or more different
   machines.
 5 [0005]      One such technique involves encrypting messages prior to transmitting
   those messages from one machine within the computer network to another. In a
   typical implementation, an originating machine transmits a security "certificate" to
   other computing machines within the computer network. The security certificate
   includes information setting forth the manner in which a message needs to be
10 encrypted in order for the machine transmitting the certificate to be able to decrypt the
   message.
   [0006]      A typical approach for establishing secure communications between a client
   and a server begins with the client issuing a request for a secure session to a server.
   The server responds by transmitting a certificate to the client that contains the
15 server's public key. The client then verifies the authenticity of the certificate by
   issuing authentication requests to one or more authentication servers associated with
   certification authorities. One or more of the authentication servers transmits an
   authentication response to the client indicating whether the certificate is valid or has
   been revoked or otherwise compromised. If the client determines, from the
20 authentication responses, that the certificate is valid, then the client generates a key,
   encrypts the key using the certificate, and transmits the encrypted key to the server.
   The client and server can then securely exchange one or more data messages, also
   referred to as payload data, where the data messages are encrypted with the key.
   [0007]      One drawback to the above approach is that large numbers of messages
25 are typically sent among the client, server, and authentication servers before any
   actual data messages may be securely exchanged. As a result, a significant amount
   of time can pass before a client and server are actually able to securely exchange
   data messages. For example, up to eleven pairs of messages could be exchanged to
   establish secure communications before any data messages can be securely
30 exchanged. Another drawback to the above approach is that the time and bandwidth
   devoted to establishing secure communications between the client and server may be
   relatively high compared to the time and bandwidth devoted to transmitting actual

   data between the client and server. As a result, the overall efficiency of the
   communication channel between the client and server may be negatively impacted.
   [0008]      As the foregoing illustrates, what is needed in the art is more efficient way
   to initiate secure communications between a client and a server or other set of
 5 network connected entities in a computer network.
   SUMMARY OF THE INVENTION
   [0009]       One embodiment of the present invention sets forth a computer
   implemented method for efficient start-up for secured connections and related
   services. The method includes receiving, via an application program, a request to
10 send a secure message to a server machine. The method further includes
   transmitting a plurality of messages to the server machine that includes a first
   message comprising at least two of user authentication data, entity authentication
   data, key exchange data, and encrypted message data. The method further includes
   receiving, from the server machine, a second message that includes a first master
15 token comprising a first set of session keys for encrypting and authenticating
   messages exchanged with the server machine.
   [0010]       Other embodiments of the present invention include, without limitation, a
   computer-readable medium including instructions for performing one or more aspects
   of the disclosed techniques, as well as a client machine, server machine, or other
20 computing device for performing one or more aspects of the disclosed techniques.
   [0011]      At least one advantage of the disclosed approach is that the client machine
   transmits a request for a secure session, authentication data, and even payload data
   to the server in a single message. The server responds by transmitting a message
   that includes a master token, user ID token, key exchange data, and payload data in
25 a single message. As a result, a secure communications session is established and
   data is exchange via a single pair of messages, leading to improved latency and
   efficiency relative to prior approaches.
   BRIEF DESCRIPTION OF THE DRAWINGS
   [0012]       So that the manner in which the above recited features of the present
30 invention can be understood in detail, a more particular description of the invention,
   briefly summarized above, may be had by reference to embodiments, some of which

   are illustrated in the appended drawings. It is to be noted, however, that the
   appended drawings illustrate only typical embodiments of this invention and are
   therefore not to be considered limiting of its scope, for the invention may admit to
   other equally effective embodiments.
 5 [0013]      Figure 1 is a block diagram illustrating a computer system configured to
   implement one or more aspects of the present invention;
   [0014]      Figure 2 illustrates a networked computing system configured to implement
   one or more aspects of the present invention;
   [0015]      Figure 3 sets forth a flow diagram of method steps for establishing secure
10 communications between a client machine and a server machine, according to one
   embodiment of the present invention;
   [0016]      Figures 4A-4B set forth a flow diagram of method steps for renewing secure
   communications between a client machine and a server machine, according to one
   embodiment of the present invention; and
15 [0017]      Figure 5 sets forth a series of method steps for exchanging secure
   messages between a client machine and a server machine, according to one or more
   embodiments of the present invention.
   DETAILED DESCRIPTION
   [0018]      In the following description, numerous specific details are set forth to
20 provide a more thorough understanding of the present invention. However, it will be
   apparent to one of skill in the art that the present invention may be practiced without
   one or more of these specific details.
   [0019]      Techniques are described herein for authenticating and encrypting
   messages exchanged between client machines and server machines. The
25 techniques are referred to herein as "message security layer" (MSL). In one
   embodiment, multiple types of authentication (such as user authentication and entity
   authentication), cryptographic key exchanges, and payload data may be made in one
   pair of messages exchanged between the client machine and the server machine.
   For example, a sending machine could include entity authentication data, user

   authentication data, payload data and a key request in a single message. These
   techniques are now described in greater detail below.
                                        System Overview
   [0020]      Figure 1 is a block diagram illustrating a machine 100 configured to
 5 implement one or more aspects of the present invention. Machine 100 may be a
   personal computer, video game console, personal digital assistant, mobile phone,
   mobile device or any other device suitable for practicing one or more embodiments of
   the present invention.
   [0021]     As shown, machine 100 includes, without limitation, a central processing
10 unit (CPU) 102 and a system memory 104 communicating via a bus path that may
   include a memory bridge 105. CPU 102 includes one or more processing cores, and,
   in operation, CPU 102 is the master processor of machine 100, controlling and
   coordinating operations of other system components. System memory 104 stores
   software applications and data for use by CPU 102. CPU 102 runs software
15 applications and optionally an operating system. Memory bridge 105, which may be,
   e.g., a Northbridge chip, is connected via a bus or other communication path (e.g., a
   HyperTransport link) to an I/O (input/output) bridge 107. 1/O bridge 107, which may
   be, e.g., a Southbridge chip, receives user input from one or more user input devices
   108 (e.g., keyboard, mouse, joystick, digitizer tablets, touch pads, touch screens, still
20 or video cameras, motion sensors, and/or microphones) and forwards the input to
   CPU 102 via memory bridge 105.
   [0022]     A display processor 112 is coupled to memory bridge 105 via a bus or other
   communication path (e.g., a PCI Express, Accelerated Graphics Port, or
   HyperTransport link); in one embodiment display processor 112 is a graphics
25 subsystem that includes at least one graphics processing unit (GPU) and graphics
   memory. Graphics memory includes a display memory (e.g., a frame buffer) used for
   storing pixel data for each pixel of an output image. Graphics memory can be
   integrated in the same device as the GPU, connected as a separate device with the
   GPU, and/or implemented within system memory 104.
30 [0023]      Display processor 112 periodically delivers pixels to a display device 110
   (e.g., a screen or conventional CRT, plasma, OLED, SED or LCD based monitor or
   television).   Additionally, display processor 112 may output pixels to film recorders

   adapted to reproduce computer generated images on photographic film. Display
   processor 112 can provide display device 110 with an analog or digital signal.
   [0024]     A system disk 114 is also connected to 1/O bridge 107 and may be
   configured to store content and applications and data for use by CPU 102 and display
 5 processor 112. System disk 114 provides non-volatile storage for applications and
   data and may include fixed or removable hard disk drives, flash memory devices, and
   CD-ROM, DVD-ROM, Blu-ray, HD-DVD, or other magnetic, optical, or solid state
   storage devices.
   [0025]     A switch 116 provides connections between 1/O bridge 107 and other
10 components such as a network adapter 118 and various add-in cards 120 and 121.
   Network adapter 118 allows machine 100 to communicate with other systems via an
   electronic communications network, and may include wired or wireless
   communication over local area networks and wide area networks such as the Internet.
   [0026]     Other components (not shown), including USB or other port connections,
15 film recording devices, and the like, may also be connected to 1/O bridge 107. For
   example, an audio processor may be used to generate analog or digital audio output
   from instructions and/or data provided by CPU 102, system memory 104, or system
   disk 114. Communication paths interconnecting the various components in Figure 1
   may be implemented using any suitable protocols, such as PCI (Peripheral
20 Component Interconnect), PCI Express (PCI-E), AGP (Accelerated Graphics Port),
   HyperTransport, or any other bus or point-to-point communication protocol(s), and
   connections between different devices may use different protocols, as is known in the
   art.
   [0027]     In one embodiment, display processor 112 incorporates circuitry optimized
25 for graphics and video processing, including, for example, video output circuitry, and
   constitutes a graphics processing unit (GPU). In another embodiment, display
   processor 112 incorporates circuitry optimized for general purpose processing. In yet
   another embodiment, display processor 112 may be integrated with one or more other
   system elements, such as the memory bridge 105, CPU 102, and 1/O bridge 107 to
30 form a system on chip (SoC). In still further embodiments, display processor 112 is
   omitted and software executed by CPU 102 performs the functions of display
   processor 112.

   [0028]      Pixel data can be provided to display processor 112 directly from CPU 102.
   In some embodiments of the present invention, instructions and/or data representing
   a scene are provided to a render farm or a set of server computers, each similar to
   machine 100, via network adapter 118 or system disk 114. The render farm
 5 generates one or more rendered images of the scene using the provided instructions
   and/or data. These rendered images may be stored on computer-readable media in a
   digital format and optionally returned to machine 100 for display. Similarly, stereo
   image pairs processed by display processor 112 may be output to other systems for
   display, stored in system disk 114, or stored on computer-readable media in a digital
10 format.
   [0029]      Alternatively, CPU 102 provides display processor 112 with data and/or
   instructions defining the desired output images, from which display processor 112
   generates the pixel data of one or more output images, including characterizing
   and/or adjusting the offset between stereo image pairs. The data and/or instructions
15 defining the desired output images can be stored in system memory 104 or graphics
   memory within display processor 112. In an embodiment, display processor 112
   includes 3D rendering capabilities for generating pixel data for output images from
   instructions and data defining the geometry, lighting shading, texturing, motion, and/or
   camera parameters for a scene. Display processor 112 can further include one or
20 more programmable execution units capable of executing shader programs, tone
   mapping programs, and the like.
   [0030]      CPU 102, render farm, and/or display processor 112 can employ any
   surface or volume rendering technique known in the art to create one or more
   rendered images from the provided data and instructions, including any rendering or
25 image processing techniques known in the art.
   [0031]      It will be appreciated that the system shown herein is illustrative and that
   variations and modifications are possible. The connection topology, including the
   number and arrangement of bridges, may be modified as desired. For instance, in
   some embodiments, system memory 104 is connected to CPU 102 directly rather
30 than through a bridge, and other devices communicate with system memory 104 via
   memory bridge 105 and CPU 102. In other alternative topologies display processor
   112 is connected to 1/O bridge 107 or directly to CPU 102, rather than to memory
   bridge 105. In still other embodiments, 1/O bridge 107 and memory bridge 105 might

   be integrated into a single chip. The particular components shown herein are
   optional; for instance, any number of add-in cards or peripheral devices might be
   supported. In some embodiments, switch 116 is eliminated, and network adapter 118
   and add-in cards 120, 121 connect directly to 1/O bridge 107.
 5                    Client/Server Communications over the Network
   [0032]     Figure 2 illustrates a computer network 200 configured to implement one or
   more aspects of the present invention. As shown, the computer network 200
   includes, without limitation, a client machine 202, a server machine 204, and a user
   service system 250 connected to each other via a communications network 206. The
10 communications network 206 may be any suitable environment to enable
   communications among remotely located machines, including, without limitation, a
   LAN (Local Area Network) and a WAN (Wide Area Network).
   [0033]     The client machine 202 is configured to exchange data with a server
   machine 204. In some embodiments, the client machine 202 and the server machine
15 204 may also communicate with one or more user service system 250s, such as user
   service system 250. The client machine 202 is configured to transmit messages to
   the server machine 204. The server machine 204 is likewise configured to transmit
   messages to the client machine 202. The messages exchanged between the client
   machine 202 and the server machine 204 include one or more of message data,
20 authentication information, authorization information, tokens, key exchange data,
   authenticated data and encrypted data. In some embodiments, the client machine
   202 and the server machine 204 may communicate with the user service system 250
   for the purpose of user authentication, as further described herein.
   [0034]     The client machine 202 includes an AES module 210, a MAC module 212,
25 a key exchange module 214, a key derivation module 216, a base authentication
   module 218, a user authentication module 220, and an application program 226. The
   server machine 204 includes an AES module 230, a MAC module 232, a key
   exchange module 234, a key derivation module 236, a base authentication module
   238, a master token generator 240, a user ID token generator 242, a service token
30 generator 244, and an application program 246. The functions of these various
   modules and token generators are now described in further detail.

   [0035]      The Advanced Encryption Standard (AES) modules 210 and 230 perform
   symmetric key cryptography on data transmitted between the client machine 202 and
   the server machine 204. The AES module 210 in the client machine 202 encrypts
   data for transmission from the client machine 202 to the server machine 204, and
 5 decrypts data received by the client machine 202 from the server machine 204.
   Likewise, the AES module 230 in the server machine 204 encrypts data for
   transmission from the server machine 204 to the client machine 202, and decrypts
   data received by the server machine 204 from the client machine 202.
   [0036]      The AES modules 210 and 230 perform two operations. The first operation
10 encrypts plaintext into ciphertext according to equation (1) below:
          ciphertext = encrypt (plaintext, aeskey, mode, initialization_vector)       (1)
   where plaintext is the unencrypted text prior to encryption, aeskey and
   initializationvector are parameters employed by the AES units 210 or 230 to encrypt
   the text according to the Advanced Encryption Standard, and ciphertext is the
15 resulting encrypted text. In some embodiments, an initialization vector is not needed
   for certain cipher modes of the algorithm. Mode is a configuration parameter for
   encryption and decryption operations, where mode includes, without limitation,
   electronic code book (ECB) mode, cipher-block chaining (CBC) mode, and counter
   mode.
20 [0037]      The second operation decrypts plaintext from ciphertext according to
   equation (2) below:
          plaintext = decrypt (ciphertext, aeskey, mode, initialization_vector)       (2)
   where ciphertext is the encrypted text prior to decryption, aeskey and
   initializationvector are parameters employed by the AES modules 210 and 230 to
25 decrypt the text according to the Advanced Encryption Standard, and plaintext is the
   resulting decrypted text. In some embodiments, an initialization vector is not needed
   for certain cipher modes of the algorithm. Mode is a configuration parameter for
   encryption and decryption operations, where mode includes, without limitation, ECB
   mode, CBC mode, and counter mode.

   [0038]      In various embodiments, the AES modules 210 and 230 may be
   implemented in software, hardware, or any combination of hardware or software. In
   particular, the AES modules 210 and 230 may be implemented in a hardware security
   module (HSM) or inside a trusted execution environment (TEE) for security purposes.
 5 In some embodiments, symmetric key crypto algorithms other than AES may be used.
   In such cases, the AES modules 210 and 230 may be replaced by an module that
   performs an alternative symmetric key crypto algorithms, including, without limitation,
   Blowfish, Twofish, and TripleDES. In various embodiments, the AES modules 210
   and 230 may be stateless or stateful, depending at least on the mode.
10 [0039]      The Message Authentication Code (MAC) modules 212 and 232 perform
   authentication and integrity protection associated with data transmitted between the
   client machine 202 and the server machine 204. The MAC module 212 in the client
   machine 202 generates a MAC corresponding to data for transmission from the client
   machine 202 to the server machine 204, and verifies a received MAC against the
15 corresponding data received by the client machine 202 from the server machine 204.
   Likewise, the MAC module 232 in the server machine 204 generates a MAC
   corresponding to data for transmission from the server machine 204 to the client
   machine 202, and verifies a received MAC against the corresponding data received
   by the server machine 204 from the client machine 202.
20 [0040]      In various embodiments, the MAC modules 212 and 232 may employ any
   technically feasible message authentication code technique, including, without
   limitation, keyed-hash MAC (HMAC), parallelizable MAC (PMAC), or universal
   hashing MAC (UMAC). By way of example only, the MAC modules 212 and 232
   described herein employ HMAC.
25 [0041]      The MAC modules 212 and 232 perform two operations. The first operation
   generates a MAC corresponding to particular data according to equation (3) below:
                   mac = generate (data, mac-key, [hashalgorithm])                     (3)
   where data is the input data for which the MAC is generated, mackey is a parameter
   employed by the MAC modules 212 and 232 to generate the MAC according to the
30 selected MAC standard, and mac is the generated MAC. Typically, a generated MAC
   is transmitted along with the corresponding data. hash_algorithm is a parameter

   needed by some MAC algorithms that specifies a particular hash algorithm. For
   example, if the MAC module employs HMAC, the value of hashalgorithm could
   include, without limitation, SHA-1, SHA-256, or SHA-3. If the MAC module employs
   PMAC or UMAC, the hash-algorithm could be omitted.
 5 [0042]     The second operation verifies whether a given set of data generates a
   corresponding MAC according to equation (4) below:
                       {TIF} = verify (data, mac, [hash algorithm])                    (4)
   where data is the data being authenticated and verified for integrity, mac is the
   corresponding MAC, and {TIF} is a Boolean value that is true if the MAC modules 212
10 or 232 successfully verifies the MAC against the data, and false otherwise. As
   described above, hashalgorithm is a parameter needed by some MAC algorithms
   that specifies a particular hash algorithm.
   [0043]      In various embodiments, the MAC modules 212 and 232 may be
   implemented in software, hardware, or any combination of hardware or software. In
15 particular, the MAC modules 212 and 232 may be implemented in an HSM or TEE for
   security purposes. The MAC modules 212 and 232 may be stateless.
   [0044]     The key exchange modules 214 and 234 are used to exchange keys
   between client machine 202 and server machine 204. In various embodiments, the
   key exchange modules 214 and 234 may employ any technically feasible key
20 exchange technique, including, without limitation, Diffie-Hellman or cryptographic key
   wrapping methods. By way of example only, the key exchange modules 214 and 234
   described herein employ Diffie-Hellman key exchange.
   [0045]      In the Diffie-Hellman embodiment, the key exchange module 214 in the
   client machine 202 generates a public value 'A' to transmit to the server machine 204,
25 and computes a shared secret value from a private value 'a' retained by the client
   machine 202 and a public value 'B' received from the server machine 204. Likewise,
   the key exchange module 234 in the server machine 204 generates a public value 'B'
   to transmit to the client machine 202, and computes the shared secret value from a
   private value 'b' retained by the server machine 204 and the public value 'A received
30 from the client machine 202.

   [0046]      The Diffie-Hellman embodiment of the key exchange modules 214 and 234
   perform two operations. The first operation calculates the public values A and B from
   the private values a and b according to equations (5) and (6) below:
                    Client public key: A = generate (g, p) = ga mod p                   (5)
 5                  Server public key: B = generate (g, p) = gb mod p                   (6)
   where A is the client machine 202 public value, a is the client machine 202 private
   value, B is the server machine 204 public value, b is the server machine 204 private
   value, and g (generator value) and p (prime value) are additional parameters for
   generating the keys.
10 [0047]      After calculating the public keys, the key exchange module 214 transmits
   the public value 'A' for the client machine 202 to the server machine 204. The key
   exchange module 234 transmits the public value 'B' for the server machine 204 to the
   client machine 202. In one embodiment, the key exchange module 214 may
   additionally transmit the 'g' and 'p' values to the server machine 204. In another
15 embodiment, the key exchange modules 214 and 234 may have previously shared, or
   otherwise agreed upon, the 'g' and 'p' values.
   [0048]      The second operation of the Diffie-Hellman embodiment is calculating the
   shared secret (ss) value according to equations (7) and (8) below:
            Client shared secret: ss = calculate (B) = gab mod p = Ba mod p             (7)
20         Server shared secret: ss = calculate (A) = gab mod p = Ab mod p              (8)
   [0049]      The client machine 202 and the server machine 204 generate the same
   value for the shared secret. The client machine 202 generates the value of the
   shared secret based on 'g', 'p', the client machine 202 private value 'a', and the server
   machine 204 public value 'B'. Likewise, the server machine 204 generates the same
25 value of the shared secret based on 'g', 'p', the server machine 204 private value 'b',
   and the client machine 202 public value 'A'.
   [0050]      Typically, the key exchange module 214 on the client machine 202 is
   stateful and the key exchange module 234 on the server machine 204 is stateless.
   However, in some embodiments, the key exchange module 234 may be stateful. In

   particular, key exchange module 214 stores 'a' as state at least until the
   corresponding B value is returned by the server machine 204. The key exchange
   module 234 calculates the 'b' value, but does not need to maintain 'b' as state.
   Rather, the key exchange module 234 typically discards 'b' after the server machine
 5 204 calculates the shared secret value and transmits the B key to the client machine
   202.
   [0051]     The key derivation modules 216 and 236 compute the session keys from
   the shared secret value computed by the key exchange modules 214 and 234. Each
   set of session keys includes two keys, namely, the HMAC key and the AES key,
10 discussed above. The session keys are employed by various entities engaging in
   secure communications for the purpose of encrypting and authenticating messages.
   Each message created by an entity using the MSL protocol may include both
   authentication/integrity protection, provided by the generated HMAC using the HMAC
   key, and data encryption, provided by the AES key. The HMAC key provides
15 authentication and integrity protection for exchanged messages, while the AES key
   provides privacy by encrypting the data in the message. The key derivation modules
   216 and 236 compute the session keys according to equation (9) below:
                 {k-sess-hmac I ksess_aes} = keyderive (keydata)                      (9)
   where, in the Diffie-Hellman embodiment, keydata is the shared secret computed by
20 the key exchange modules 214 and 234 and {k-sesshmac I ksessaes} is the
   session key, which is a concatenation of the HMAC session key and the AES session
   key. The keyderive function may be any technically feasibly key derivation or
   generation technique. In one non-limiting example, the keyderive function could be
   based on SHA-384, which generates 384 bits of key data. In this example, the AES
25 session key could be the leftmost 128 bits of the SHA-384 generated key data, while
   the HMAC session key could be a 256 bit key that includes the rightmost 256 bits of
   the SHA-384 key data.
   [0052]      In various embodiments, the session keys may include other keys instead
   of or in addition to an HMAC key and an AES key.

   [0053]     The key exchange modules 214 and 234 may exchange, in the Diffie
   Hellman embodiment, public values and may compute a "shared secret" value that is
   private to the corresponding client machine 202 and server machine 204.
   [0054]     The base authentication modules 218 and 238 provide authentication of the
 5 server machine 204 to the client machine 202 in two circumstances. The first
   circumstance is during the initial exchange of messages between the client machine
   202 and the server machine 204 prior to the establishment of session keys and
   exchange of master tokens. The second circumstance is when the server machine
   204 receives a bad message from the client machine 202, as indicated by, for
10 example, failing to decrypt data received from the client machine 202 or failing to
   verify an authentication code received from the client machine 202. In other words,
   base authentication modules 218 and 238 provide authentication on initial message
   exchange and as failure recovery authentication when a message failure is detected.
   [0055]      In various embodiments, the base authentication modules 218 and 238
15 may employ any technically feasible authentication technique or algorithm, including,
   without limitation, Rivest-Shamir-Adleman (RSA) public/private keys, elliptic-curve
   cryptography, digital signature algorithm (DSA), or Diffie-Hellman. By way of example
   only, the base authentication modules 218 and 238 described herein employ RSA
   public/private keys.
20 [0056]     When the server machine 204 detects a failure or when exchanging initial
   messages with the client machine 202, the base authentication module 238 on the
   server machine 204 generates a signature to transmit to the client machine 202
   according to equation (10) below:
                   sig = sign (data, RSA privatekey, hashalgorithm)                    (10)
25 where data is the data for transmission to the client machine 202, RSA privatekey is
   the private RSA key held by the server machine 204, hashalgorithm identifies a
   particular hash technique, as described herein, and sig is the signature for
   transmission to the client machine 202 along with the data.
   [0057]     When the client machine 202 receives the message from the server
30 machine 204, the base authentication module 218 on the client machine 202 verifies
   the message according equation (11) below:

              {TIF} = verify (sig, data, RSA publickey, hashalgorithm)                 (11)
   where sig is the received signature generated by the server, data is the corresponding
   received data, RSApublickey is the public RSA key which has been pre-provisioned
   or previously received from the server machine 204, hashalgorithm identifies a
 5 particular hash technique, and {TIF} is a Boolean value that is true if the base
   authentication modules 218 successfully verifies the signature against the data, and
   false otherwise.
   [0058]     The user authentication module 220 optionally provides user authentication
   from the client machine 202. When a user of the client machine 202 enters, for
10 example, a username and password, the user authentication module 220 or the user
   service system 250 determines whether the user has entered valid login credentials.
   The user authentication module 220 may make this determination by querying locally
   stored password data or may query a user service system 250. The user
   authentication module 220 may transmit the username and password to the server
15 machine 204. Optionally, the user authentication module 220 may encrypt or hash
   the password prior to querying local password data or transmitting the username and
   password to the user service system 250 or the server machine 204.
   [0059]     The master token generator 240 on the server machine 204 generates
   master tokens to enable the client machine 202 and the server machine 204 to
20 exchange messages securely. The master token generator 240 generates a pre
   master token according to equation (12) below:
    pre_MT = issue (ID, ksess, renewtime, exp time, seqnum, MTsernum)                  (12)
   where the ID is a unique identifier, ksess is the set of session keys generated by the
   key derivation module 236 (previously described as the HMAC key and AES key),
25 renewtime indicates a time at which the server may choose to renew the master
   token when a message from the client is received with the renewable flag set,
   exp time is the time when the current master token expires, seqnum is an anti-theft
   sequence number that is incremented when the master token is renewed,
   MTsernum is the master token serial number for token binding purposes, and
30 pre_MT is the generated pre-master token. The ID is one or both of a client ID and
   an issuer ID, where the client ID identifies the client machine 202 and the issuer ID

   identifies the server machine 204 that issued the master token. In one embodiment,
   the ID is the concatenation of the client ID and the issuer ID.
   [0060]      The master token generator 240 then generates the final master token
   according to equation n(13) below:
 5                            MT = encrypt (pre_MT, MT key)                            (13)
   where preMT is the pre-master token, MT key is a master token encryption key,
   such as an AES key known only to the server machine 204 and other servers that
   share the MT key in order to create a network of trust, and MT is the encrypted
   master token.
10 [0061]      The user ID token generator 242 verifies user authentication and issues
   user ID tokens. The user ID token generator 242 may verify user authentication by
   querying a user service system 250 using equation (14) below:
                            {TIF} = userauth (user auth data)                          (14)
   where userauthdata is any technically feasible user authentication data supported
15 by the user service system 250, such as username and password, and {TIF} is a
   Boolean value returned by the user service system 250 that is true if the user
   authentication data is valid, and false otherwise.
   [0062]      If the user is authenticated, then the user ID token generator 242 generates
   a pre-user ID token according to equation (15) below:
20                 preUIDT = issue (MT sernum, UIDTrenewtime,                          (15)
                                       UIDTexptime, UIDTser-num, userdata)
   where MT ser num is the master token serial number, UIDT renew time indicates a
   time when a user ID renewable message is to be transmitted by the server machine
   204, exptime is the time when the current user ID token session expires,
25 UIDTsernum is the user ID token serial number for binding purposes, userdata is
   user data to be encrypted, and preUIDT is the generated pre-user ID token.
   Because user authentication typically involves querying an external user server
   system 250, the UIDTrenewtime and UIDTexptime are typically longer than the
   corresponding master token renew-time and exptime. The MTsernum is used in

   the generation of the user ID token to ensure that the user ID token is bound to the
   master token.
   [0063]      The user ID token generator 242 then generates the final user ID token
   according to equation (16) below:
 5                       UIDT = encrypt (preUIDT, UIDT key)                            (16)
   where preUIDT is the pre-user ID token, UIDTkey is a user token encryption key,
   such as an AES key known only to the server machine 204 and other servers that
   share the UIDT key in order to create a network of trust, and UIDT is the encrypted
   user ID token.
10 [0064]      The service token generator 244 generates and encrypts service tokens
   used by various services to persist state information in client stored tokens such that
   the server does not need to persist such state. In various embodiments, service
   tokens may be bound to both master tokens and user ID tokens, to master tokens
   only, or to no other tokens. The service token generator 244 generates pre-service
15 tokens according to equation (17) below:
                preST = (name, data, [MT ser num], [UIDT-ser-num])                     (17)
   where name is the name of the service token and data is any arbitrary data from the
   corresponding service. In other words, name and data form a key-value pair,
   essentially operating as an HTTP cookie. Optional parameters include MTsernum
20 (if the service token is bound to a master token), and UIDTsernum (if the service
   token is bound to a user UD token). pre_ST is the pre-service token.
   [0065]      The service token generator 244 then generates the final service token
   according to equation (18) below:
                             ST = encrypt (pre_ST, ST key)                             (18)
25 where preST is the pre-service token, STkey is a service token encryption key,
   such as an AES key, and ST is the encrypted service token. In some embodiments,
   the service token may not be encrypted, in which case, the service token is given by
   equation (19) below:
                                      ST = pre_ST                                      (19)

   [0066]        The application program 226 residing on the client machine 202 and the
   application program 246 residing on the server machine 204 communicate securely
   with each other via the various modules and generators described herein in
   conjunction with Figure 2. In one example, and without limitation, application
 5 programs 226 and 246 could be configured to securely stream media content
   between the client machine 202 and the server machine 204.
   [0067]        In at least one embodiment, application program 226 residing on the client
   machine 202 may transmit a request to establish a secure communication channel
   with application program 246 residing on the server machine 204. The application
10 program 226 may transmit such a request to one or more of the modules and
   generators residing on the client machine 202 as described herein. In response to
   this request, the modules and generators residing on the client machine 202 may
   exchange one or more messages with the modules and generators residing on the
   server machine 204, thereby establishing a secure communication channel between
15 the application program 226 residing on the client machine 202 and the application
   program 246 residing on the server machine 204.
   [0068]        Although the modules and token generators are described in a particular
   order, the operations performed by these modules and token generators may be
   performed in any technically feasible order. For example, the functions performed by
20 the user authentication module 220 could be performed either before or after the
   operations performed by the base authentication modules 218 and 238. In particular,
   if a initialization scheme which does not support encryption is used with a user
   authentication scheme that requires encryption, then a key exchange may need to
   happen prior to initiation of user authentication in order to ensure secure data
25 transfer. Such an approach may result in additional round-trip message exchange.
   [0069]        In another example, the master token generator 240, user ID token
   generator 242, and service token generator 244 may be implemented as separate
   token generators, as a single token generator that generates all three token types, or
   in any technically feasible combination.
30              Efficient Start-Up for Secured Connection and Related Services
   [0070]        In order to establish a secure communication channel, a client machine 202
   transmits a message including authentication data and a key request to a server

   machine 204. In one embodiment, this message may include payload data. The
   server machine 204 responds by sending a user ID token along with key response
   data that includes a master token. In one embodiment, this message may likewise
   include payload data. As a result, a secure communication channel is established
 5 and payload data may be exchanged via the exchange of one pair of messages
   between a client machine 202 and a server machine 204. This technique is now
   described.
   [0071]      Figure 3 sets forth a flow diagram of method steps for establishing secure
   communications between a client machine and a server machine, according to one
10 embodiment of the present invention. Although the method steps are described in
   conjunction with the systems of Figures 1-2, persons of ordinary skill in the art will
   understand that any system configured to perform the method steps, in any order, is
   within the scope of the present invention.
   [0072] As shown, a method 300 begins at step 302, where the client machine 202
15 creates entity authentication data. The entity authentication data includes data used
   to identify and authenticate the entity associated with a message. The entity
   authentication data may be unencrypted, or the entity authentication data may be
   encrypted via any technically feasible approach, such as via pre-shared keys. At step
   304, the client machine 202 creates user authentication data. The user authentication
20 data may be of any technically feasible format, including, without limitation, username
   with password, username with hashed password, or information associated with an
   http cookie. At step 306, the client machine 202 creates a key request directed to the
   server machine 204 for which a secure communication channel is desired. At step
   308, the client machine 202 transmits a renewable MSL message to the server
25 machine 204 that includes the entity authentication data, the user authentication data
   and the key request. In some embodiments, the MSL message may include payload
   data.
   [0073]      At step 310, the server machine 204 authenticates the entity authentication
   data and the user authentication data. At step 312, the server machine 204 decrypts
30 the MSL message to recover the key request and optional payload data. At step 314,
   the server machine 204 generates a new user ID token. The server machine also
   generates key response data that includes a new master token. In some
   embodiments, the key response data also includes session keys. At step 316, the

   server machine 204 generates an MSL message that includes entity authentication
   data and the key response data, including the new master token. In some
   embodiments, the MSL message may include either or both of session keys and
   payload data. At step 318, the server machine 204 transmits the MSL message to
 5 the client machine 202. The method 300 then terminates.
   [0074]      Once secure communications are established between the client machine
   202 and the server machine 204, the master token may become "renewable" or may
   expire with the passage of time or after exchange of a specified quantity of messages.
   The secure communication channel credentials may then be renewed by requesting a
10 new master token and user ID token. In one embodiment, credential renewability
   may be based on an explicit "renewable" flag in order to improve threading and
   synchronization performance relative to prior approaches. When a time
   corresponding to a renewable window is reached, a sending device may include the
   current master token and key request data in a message that is identified as
15 renewable. In response, a server machine 204 may determine whether and when to
   renew credentials. Typically, a server machine 204 may renew credentials at the time
   a message identified as renewable is received. In some cases, such as when there is
   a significant computational load on the server machine 204, the server machine 204
   may defer credential renewal until a later time. In a trusted services network the
20 response includes key response data containing a new master token. Authentication
   of the response, or of any given message, is performed via the combination of the
   current master token, which contains the session keys, and the usage of the session
   key itself. In a peer-to-peer network, the response includes key response data that
   includes a new master token. This technique is now described.
25 [0075]      Figures 4A-4B set forth a flow diagram of method steps for renewing secure
   communications between a client machine and a server machine, according to one
   embodiment of the present invention. Although the method steps are described in
   conjunction with the systems of Figures 1-2, persons of ordinary skill in the art will
   understand that any system configured to perform the method steps, in any order, is
30 within the scope of the present invention.
   [0076]  As shown, a method 400 begins at step 402, where the client machine 202
   determines that the current master token is renewable or expired. The current master
   token may be renewable or expired based on the passage of time or after exchange

   of a specified quantity of messages. At step 404, the client machine 202 retrieves the
   current master token and the current user ID token. At step 406, the client machine
   202 creates a key request directed to the server machine 104 to which a secure
   communication channel has been established. At step 408, the client machine 202
 5 transmits a renewable MSL message to the server machine 204 that includes the
   current master token, the current user ID token, and the key request. In some
   embodiments, the MSL message may include payload data.
   [0077]     At step 410, the server machine 204 authenticates the entity authentication
   data and the user authentication data. At step 412, the server machine 204 decrypts
10 the MSL message to recover the key request and optional payload data. At step 414,
   the server machine 204 determines whether the server machine 204 is
   communicating with the client machine 202 over a trusted services network. If the
   server machine 204 is communicating with the client machine 202 over a trusted
   services network, then the method proceeds to step 416, where the server machine
15 204 generates a new user ID token and key response data that includes a new
   master token. At step 418, the server machine 204 generates an MSL message that
   includes the new user ID token and the key response data, including the new master
   token. In some embodiments, the MSL message may include either or both of
   session keys and payload data. At step 420, the server machine 204 transmits the
20 MSL message to the client machine 202. The method 400 then terminates.
   [0078]      Returning to step 414, if the server machine 204 is not communicating with
   the client machine 202 over a trusted services network, then the server machine 204
   is communicating with the client machine 202 over a peer-to-peer network. In such a
   case, the method proceeds to step 422, where the server machine 204 generates a
25 new user ID token and key response data that includes a new master token. At step
   424, the server machine 204 generates an MSL message that includes the entity
   authentication data and the key response data, including the new master token. In
   some embodiments, the MSL message may include either or both of session keys
   and payload data. At step 426, the server machine 204 transmits the MSL message
30 to the client machine 202. The method 400 then terminates.
   [0079]      It will be appreciated that the techniques described herein are illustrative
   and that variations and modifications are possible. For example, although the
   techniques are described with respect to transmitting MSL messages with certain

   specified components, any technically feasible combination of authentication data,
   key data, tokens, and other information may be transmitted in a single MSL message.
   A particular embodiment for exchange secure messages between a client machine
   202 and a server machine 204 is now described.
 5 [0080]     Figure 5 sets forth a flow diagram of method steps for exchanging secure
   messages between a client machine and a server machine, according to one
   embodiment of the present invention. Although the method steps are described in
   conjunction with the systems of Figures 1-2, persons of ordinary skill in the art will
   understand that any system configured to perform the method steps, in any order, is
10 within the scope of the present invention.
   [0081]     As shown, a method 500 begins at step 502, where a client machine 202
   creates key exchange data, entity authentication data, and payload data. In some
   embodiments, the client machine 202 also creates user authentication data. At step
   504, the client machine 202 packages the key exchange data, entity authentication
15 data, payload data, and, if applicable, user authentication data, into a MSL message
   based on keys that are pre-shared, or pre-provisioned, between the client machine
   202 and a server machine 204. Packaging the data into the MSL message involves:
   (a) encryption of the MSL message using a pre-provisioned client encryption key; and
   (b) authentication of the encrypted MSL message using a pre-provisioned
20 authentication key. The authentication may be accomplished via any technically
   feasible approach, including, without limitation, HMAC, RSA signature, and ECC
   signature. At step 506, the client machine 202 transmits the encrypted and
   authenticated MSL message to the server machine 204.
   [0082]     At step 508, the server machine 204 authenticates the entity authentication
25 data. In some embodiments, the server machine 204 also authenticates the user
   authentication data. At step 510, the server machine 204 decrypts the MSL message
   using the pre-shared encryption key. At step 512, the server machine 204 completes
   the key exchange handshake, producing key exchange data to return to the client,
   and generates the session keys. At step 514, the server machine 204 generates the
30 master token, where the master token includes the session keys. In various
   embodiments, the master token may also include, without limitation, an identifier (ID)
   associate with one or both of a client machine 202 ID and a master token issuer ID, a
   master token renewal time, a master token expiration time, a sequence number, and

   a master token serial number. At step 516, the server machine 204 generates a user
   ID Token and binds the user ID token to the master token using the master token
   serial number. In various embodiments, the user ID token may include a master
   token serial number, a user ID expiration time, a user ID renewal time, a user ID serial
 5 number, and user data. At step 518, the server machine 204 passes the decrypted
   payload data to an application program for processing. At step 520, the server
   machine 204 transmits a message to the client machine that includes key exchange
   data that, in turn, includes the master token. The message further includes the user
   ID token. The method 500 then terminates.
10 [0083]     In some embodiments, the server machine 204 and the client machine 202
   may not have exchanged pre-shared keys. In such embodiments, the client machine
   202 may create key exchange data, but may not create user authentication data or
   payload data at this initial step. The client machine 202 may package the key
   exchange data into a MSL message for the sole purpose of key exchange. The client
15 machine 202 may send the MSL message to the server machine 204.
   [0084]     The server machine 204 may complete the key exchange handshake by
   producing key exchange data to return to the client and may generate the session
   keys. The server machine 204 may generate the master token, where the master
   token includes the session keys. The server machine 204 may return the master
20 token to the client machine 202.
   [0085]     The client machine 202 may then create user authentication data and
   payload data. The client machine 202 may package the payload data along with the
   master token and may create a MSL message. The creation of the MSL message
   may involve: (a) encryption of the MSL message using an encryption key created
25 during key exchange; and (b) authentication of the encrypted MSL message using a
   MAC key created during key exchange. The client machine 202 may transmit the
   encrypted and authenticated MSL message to the server machine 204.
   [0086]     The server machine 204 may decrypt the master token to retrieve the
   session keys needed to authenticate and decrypt the MSL message from the client.
30 The server machine 204 may authenticate the MSL message using the MAC key
   retrieved and decrypted by the server machine 204. The server machine 204 may
   decrypt the MSL message using the encryption key retrieved and decrypted by the

   server machine 204. The server machine 204 may generate a user ID token and bind
   the user ID token to the master token using the master token serial number. The
   server machine 204 may pass the decrypted payload data to the application program
   for processing.
 5 [0087]     In sum, a secure communications channel is established between a client
   machine and a server machine. The client machine transmits authentication data, a
   request for a key session, and, optionally, payload data to the server in a single
   message. The server responds by transmitting a master token, user ID token,
   session keys, and, optionally, payload data in a single message. To renew the
10 secure communications channel, the client machine transmits the current master
   token and user ID token, a request for a new master token, and, optionally, payload
   data to the server in a single message. The server responds by transmitting a new
   master token, other authentication data, and, optionally, payload data in a single
   message.
15 [0088]      At least one advantage of the disclosed approach is that a secure
   communications session is established and data is exchanged via a single pair of
   messages, leading to improved latency and efficiency relative to conventional
   approaches. Another advantage of the disclosed approach is that credentials are
   renewed and a new master token and session keys are issued automatically with no
20 need for manual intervention. As a result, secure communications are more reliable
   and more efficient relative to conventional approaches.
   [0089]     The descriptions of the various embodiments have been presented for
   purposes of illustration, but are not intended to be exhaustive or limited to the
   embodiments disclosed. Many modifications and variations will be apparent to those
25 of ordinary skill in the art without departing from the scope and spirit of the described
   embodiments.
   [0090]     Aspects of the subject matter described herein are set out in the following
   numbered clauses.
   [0091]     1. A program product comprising a non-transitory computer-readable
30 storage medium including instructions that, when executed by a processor, cause the
   processor to perform the steps of generating entity authentication data that identifies

   and authenticates a client machine; generating user authentication data that identifies
   a user associated with the client machine; generating a first key request for a first
   plurality of session keys for encrypting and authenticating messages exchanged with
   the client machine; and transmitting a first message to a server machine that includes
 5 the entity authentication data, the user authentication data, and the first key request.
   [0092]       2. The program product of clause 1, further comprising receiving, from the
   server machine, a second message that includes a first master token comprising the
   first plurality of session keys.
10 [0093]       3. The program product of either clause 1 or 2, wherein the second
   message further includes the entity authentication data.
   [0094]       4. The program product of any of clauses 1-3, wherein the second
   message further includes a first user identification token.
   [0095]       5. The program product of any of clauses 1-4, further comprising
15 determining that the first master token is renewable; generating a second key request
   for a second plurality of session keys; and transmitting a third message to the server
   machine that includes the first master token, the first user identification token, and the
   second key request.
   [0096]       6. The program product of any of clauses 1-5, further comprising
20 identifying the third message as renewable.
   [0097]       7. The program product of any of clauses 1-6, further comprising receiving,
   from the server machine, a fourth message that includes a second master token
   comprising the second plurality of session keys.
   [0098]       8. The program product of any of clauses 1-7, wherein determining that the
25 first master token is renewable comprises determining that a threshold number of
   messages has been exchanged between the client machine and the server machine
   subsequent to receiving the first master token.
   [0099]       9. The program product of any of clauses 1-8, wherein determining that the
   first master token is renewable comprises determining that a threshold amount of time
30 has passed subsequent to receiving the first master token.

   [00100]     10. The program product of any of clauses 1-9, wherein the client machine
   and the server machine communicate via a trusted services network.
   [00101]     11. The program product of any of clauses 1-10, wherein the client
   machine and the server machine communicate via a peer-to-peer network.
 5 [00102]     12. The program product of any of clauses 1-11, wherein the first message
   further includes payload data.
   [00103]     13. A server machine, comprising a processor; and a memory coupled to
   the processor and including a base authentication module, a key derivation module,
   and a key exchange module; wherein, when executed by the processor, the base
10 authentication module is configured to receive a first message from a client machine
   that includes entity authentication data, user authentication data, and a first key
   request, and generate a signature the includes a private key for transmission to the
   client machine; wherein, when executed by the processor, the key derivation module
   is configured to generate a first set of session keys in response to the first key
15 request; and wherein, when executed by the processor, the key exchange module is
   configured to transmit a second message to the client machine that includes the
   private key and the first set of session keys.
   [00104]     14. The server machine of clause 13, wherein the memory further includes
   a master token generator, wherein, when executed by the processor, the master
20 token generator is configured to generate a first master token, and the second
   message further includes the first master token.
   [00105]     15. The server machine of either clause 13 or clause 14, wherein the
   memory further includes a user identification token generator, wherein, when
   executed by the processor, the user identification token generator is configured to
25 generate a first user identification token, and the second message further includes the
   first user identification token.
   [00106]     16. A computer-implemented method, comprising receiving, via an
   application program, a request to send a secure message to a server machine;
   transmitting a plurality of messages to the server machine that includes a first
30 message comprising at least two of user authentication data, entity authentication
   data, key exchange data, and encrypted message data; and receiving, from the

   server machine, a second message that includes a first master token comprising a
   first set of session keys for encrypting and authenticating messages exchanged with
   the server machine.
   [00107]      17. The method of clause 16, further comprising determining that a current
 5 time falls within a renewal window that defines a time after which the first master
   token is renewed if a message that is included in the plurality of messages is
   identified as renewable.
   [00108]      18. The method of either clause 16 or clause 17, further comprising
   identifying a second message included in the plurality of messages as renewable; and
10 transmitting the second message to the server machine.
   [00109]      19. The method of any of clauses 16-18, further comprising receiving a set
   of renewed credentials from the server machine that includes a second master token
   comprising a second set of session keys for encrypting and authenticating messages
   exchanged with the server machine, wherein the second master token replaces the
15 first master token and the second set of session keys replaces the first set of session
   keys.
   [00110]      20. The method of any of clauses 16-19, wherein the plurality of messages
   includes one or more additional messages that are associated with the first master
   token and transmitted to the server machine prior to receiving the set of renewed
20 credentials.
   [00111]     Aspects of the present embodiments may be embodied as a system,
   method or computer program product. Accordingly, aspects of the present disclosure
   may take the form of an entirely hardware embodiment, an entirely software
   embodiment (including firmware, resident software, micro-code, etc.) or an
25 embodiment combining software and hardware aspects that may all generally be
   referred to herein as a "circuit," "module" or "system." Furthermore, aspects of the
   present disclosure may take the form of a computer program product embodied in
   one or more computer readable medium(s) having computer readable program code
   embodied thereon.
30 [00112]     Any combination of one or more computer readable medium(s) may be
   utilized. The computer readable medium may be a computer readable signal medium

   or a computer readable storage medium. A computer readable storage medium may
   be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic,
   infrared, or semiconductor system, apparatus, or device, or any suitable combination
   of the foregoing. More specific examples (a non-exhaustive list) of the computer
 5 readable storage medium would include the following: an electrical connection having
   one or more wires, a portable computer diskette, a hard disk, a random access
   memory (RAM), a read-only memory (ROM), an erasable programmable read-only
   memory (EPROM or Flash memory), an optical fiber, a portable compact disc read
   only memory (CD-ROM), an optical storage device, a magnetic storage device, or any
10 suitable combination of the foregoing. In the context of this document, a computer
   readable storage medium may be any tangible medium that can contain, or store a
   program for use by or in connection with an instruction execution system, apparatus,
   or device.
   [00113]    Aspects of the present disclosure are described above with reference to
15 flowchart illustrations and/or block diagrams of methods, apparatus (systems) and
   computer program products according to embodiments of the disclosure. It will be
   understood that each block of the flowchart illustrations and/or block diagrams, and
   combinations of blocks in the flowchart illustrations and/or block diagrams, can be
   implemented by computer program instructions. These computer program
20 instructions may be provided to a processor of a general purpose computer, special
   purpose computer, or other programmable data processing apparatus to produce a
   machine, such that the instructions, which execute via the processor of the computer
   or other programmable data processing apparatus, enable the implementation of the
   functions/acts specified in the flowchart and/or block diagram block or blocks. Such
25 processors may be, without limitation, general purpose processors, special-purpose
   processors, application-specific processors, or field-programmable processors or gate
   arrays.
   [00114]    The flowchart and block diagrams in the figures illustrate the architecture,
   functionality, and operation of possible implementations of systems, methods and
30 computer program products according to various embodiments of the present
   disclosure. In this regard, each block in the flowchart or block diagrams may
   represent a module, segment, or portion of code, which comprises one or more
   executable instructions for implementing the specified logical function(s). It should

   also be noted that, in some alternative implementations, the functions noted in the
   block may occur out of the order noted in the figures. For example, two blocks shown
   in succession may, in fact, be executed substantially concurrently, or the blocks may
   sometimes be executed in the reverse order, depending upon the functionality
 5 involved. It will also be noted that each block of the block diagrams and/or flowchart
   illustration, and combinations of blocks in the block diagrams and/or flowchart
   illustration, can be implemented by special purpose hardware-based systems that
   perform the specified functions or acts, or combinations of special purpose hardware
   and computer instructions.
10 [00115]     While the preceding is directed to embodiments of the present disclosure,
   other and further embodiments of the disclosure may be devised without departing
   from the basic scope thereof, and the scope thereof is determined by the claims that
   follow.

   WHAT IS CLAIMED IS:
   1.    A non-transitory computer-readable storage medium including instructions that,
   when executed by a processor, cause the processor to perform the steps of:
 5       generating entity authentication data that identifies and authenticates a client
                machine;
         generating user authentication data that identifies a user associated with the
                client machine;
         generating a first key request for a first plurality of session keys for encrypting
10              and authenticating messages exchanged with the client machine; and
         transmitting a first message to a server machine that includes the entity
                authentication data, the user authentication data, and the first key
                request.
15 2.    The non-transitory computer-readable storage medium of claim 1, further
   comprising receiving, from the server machine, a second message that includes a first
   master token comprising the first plurality of session keys.
   3.    The non-transitory computer-readable storage medium of claim 2, wherein the
20 second message further includes the entity authentication data.
   4.    The non-transitory computer-readable storage medium of claim 2, wherein the
   second message further includes a first user identification token.
25 5.    The non-transitory computer-readable storage medium of claim 2, further
   comprising:
         determining that the first master token is renewable;
         generating a second key request for a second plurality of session keys; and
         transmitting a third message to the server machine that includes the first
30              master token, the first user identification token, and the second key
                request.
   6.    The non-transitory computer-readable storage medium of claim 5, further
   comprising identifying the third message as renewable.

   7.     The non-transitory computer-readable storage medium of claim 5, further
   comprising receiving, from the server machine, a fourth message that includes a
   second master token comprising the second plurality of session keys.
 5
   8.     The non-transitory computer-readable storage medium of claim 5, wherein
   determining that the first master token is renewable comprises determining that a
   threshold number of messages has been exchanged between the client machine and
   the server machine subsequent to receiving the first master token.
10
   9.     The non-transitory computer-readable storage medium of claim 5, wherein
   determining that the first master token is renewable comprises determining that a
   threshold amount of time has passed subsequent to receiving the first master token.
15 10.    The non-transitory computer-readable storage medium of claim 2, wherein the
   client machine and the server machine communicate via a trusted services network.
   11.    The non-transitory computer-readable storage medium of claim 2, wherein the
   client machine and the server machine communicate via a peer-to-peer network.
20
   12.    The non-transitory computer-readable storage medium of claim 1, wherein the
   first message further includes payload data.
   13.    A server machine, comprising:
25         a processor; and
           a memory coupled to the processor and including a base authentication
                  module; a key derivation module; and a key exchange module;
          wherein, when executed by the processor, the base authentication module is
                  configured to:
30                receive a first message from a client machine that includes entity
                         authentication data, user authentication data, and a first key
                         request, and
                 generate a signature the includes a private key for transmission to the
                         client machine;

          wherein, when executed by the processor, the key derivation module is
                 configured to:
                 generate a first set of session keys in response to the first key request;
                         and
 5        wherein, when executed by the processor, the key exchange module is
                 configured to:
                 transmit a second message to the client machine that includes the
                         private key and the first set of session keys.
10 14.    The server machine of claim 13, wherein:
          the memory further includes a master token generator, and, when executed by
                 the processor, the master token generator is configured to generate a
                 first master token, and
          the second message further includes the first master token.
15
   15.    The server machine of claim 13, wherein:
          the memory further includes a user identification token generator, and, when
                 executed by the processor, the user identification token generator is
                 configured to generate a first user identification token, and
20        the second message further includes the first user identification token.
   16.    A computer-implemented method, comprising:
          receiving, via an application program, a request to send a secure message to a
                 server machine;
25        transmitting a plurality of messages to the server machine that includes a first
                 message comprising at least two of user authentication data, entity
                 authentication data, key exchange data, and encrypted message data;
                 and
          receiving, from the server machine, a second message that includes a first
30               master token comprising a first set of session keys for encrypting and
                 authenticating messages exchanged with the server machine.
   17.    The method of claim 16, further comprising determining that a current time falls
   within a renewal window that defines a time after which the first master token is

   renewed if a message that is included in the plurality of messages is identified as
   renewable.
   18.    The method of claim 17, further comprising:
 5        identifying a second message included in the plurality of messages as
                  renewable; and
          transmitting the second message to the server machine.
   19.    The method of claim 18, further comprising receiving a set of renewed
10 credentials from the server machine that includes a second master token comprising
   a second set of session keys for encrypting and authenticating messages exchanged
   with the server machine, wherein the second master token replaces the first master
   token and the second set of session keys replaces the first set of session keys.
15 20.    The method of claim 19, wherein the plurality of messages includes one or
   more additional messages that are associated with the first master token and
   transmitted to the server machine prior to receiving the set of renewed credentials.

<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
