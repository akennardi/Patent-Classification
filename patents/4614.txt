                                           Abstract:
  A component in a graph-based computation having data processing components connected
  by linking elements representing data flows is updated by receiving a rule specification,
5 generating a transform for transforming data based on the rule specification, associating the
  transform with a component in the graph-based computation, and in response to
  determining that a new rule specification has been received or an existing rule specification
  has been edited, updating the transform associated with the component in the graph-based
  computation according to the new or edited rule specification.

WO 2008/124319                         PCT/US2008/058360
                                  1/10
                    C)O
      OC)
                              coo
              (/)C)
              (C%4
  co       Y
     C))
      00                    0
                        cn  :
                            cn
     zo   ."                0
                         LLm
                    co6E6(

   WO 2008/124319                                                          PCT/US2008/058360
             EDITING AND COMPILING BUSINESS RULES
                                      TECHNICAL FIELD
   [0001] This invention relates to editing and compiling business rules.
                                       BACKGROUND
   [0002] Complex computations can often be expressed as a data flow through a
10 directed graph, with components of the computation being associated with the vertices
   of the graph and data flows between the components corresponding to links (arcs,
   edges) of the graph. A system that implements such graph-based computations is
   described in U.S. Patent 5,966,072, EXECUTING COMPUTATIONS EXPRESSED As
   GRAPHS.   In some cases, the computations associated with a vertex is described in
15 human-readable form referred to as "business rules."
                                          SUMMARY
   [0003] In general, in one aspect, a component in a graph-based computation having
   data processing components connected by linking elements representing data flows is
   updated by receiving a rule specification, generating a transform for transforming data
20 based on the rule specification, associating the transform with a component in the
   graph-based computation, and in response to determining that a new rule specification
   has been received or an existing rule specification has been edited, updating the
   transform associated with the component in the graph-based computation according to
   the new or edited rule specification.
25 [0004] Implementations may include one or more of the following features.
   [0005] Receiving the rule specification includes receiving from a user a row of a rule
   specification table, the row defining a rule case and containing a relationship for each
   of a set of one or more potential inputs. Receiving the rule specification also includes
   receiving from the user a second row of the table, the second row defining a second
30 rule case and containing a second relationship for each of a second set of one or more
   of the potential inputs. The relationship includes one or more of having a value equal
   to a threshold, having a value above a threshold, having a value below a threshold,
   having a value belonging to a set of values, having a value matching a pattern, having

   WO 2008/124319                                                           PCT/US2008/058360
 5 a relationship to a value of another input, having a relationship to a value of an output
   of another rule specification, or having a relationship to a value in a memory. The row
   also contains an output including one or more or a combination of values of the
   inputs, a pre-determined value, or a value computed from one or more of the values of
   the inputs. Receiving a table including a set of test columns, each test column
10 containing a value for one or more of the potential inputs, and for each test column,
   identifying a row of the rule specification that will generate an output given the input
   values of the test column, and outputting to a user the identification of the identified
   row for each test column. Generating a table including a results row for each test
   column, each results row indicating an output that will be generated given the input
15 values of the test column. Generating the table includes, in each results row,
   indicating whether the output that will be generated is changed from an output that
   was indicated for a previous version of the rule specification. In response to a user
   interaction with a results row, indicating which rule case of the rule specification will
   generate the output in that results row.
20 [0006] Generating a table including an evaluation row corresponding to each row of
   the rule specification, in each evaluation row of the table, for each potential input,
   indicating whether the value in a first test column for that potential input satisfied the
   relationship for that potential input, and in an evaluation row corresponding to the row
   of the rule specification that will generate an output given the input values of the first
25 test column, indicating the output that will be generated. The evaluation rows have an
   order corresponding to an order of the rows of the rule specification, and the
   evaluation row in which the output is indicated corresponds to the first row of the rule
   specification for which each of the relationships for the potential inputs is satisfied.
   Indicating an output that will be generated in each evaluation row corresponding to a
30 row of the rule specification for which each of the relationships for the potential
   inputs is satisfied. Generating a table including an evaluation row corresponding to
   each row of the rule specification, in each evaluation row, indicating how many test
   columns have inputs that satisfy the relationships in the corresponding row of the rule
   specification. Each test column also contains an expected output value, each results
35 row indicating whether the output that will be generated given the input values of the
   corresponding test column match the expected output in that test column. In response
   to determining that, for each test column, at least one row of a second rule
                                                 2

   WO 2008/124319                                                           PCT/US2008/058360
 5 specification will generate an output given the input values of the test column,
   determining that a rule set including the first rule specification and the second rule
   specification is valid.
   [0007] Generating a table including a results row for each test column, each results
   row indicating each output generated by a row in one of the rule specifications given
10 the input values of the test column. For an output that will be generated given the
   input values of a first test column, generating a graphical display of interrelationships
   between inputs and outputs of rule specifications that will result in the generation of
   that output. Receiving the table of test column includes receiving from a user a set of
   input values, matching the set of input values to the potential input values of the rule
15 specification, and storing the set of input values to a column of the table. The
   receiving of a set of input values is in response to displaying identifications of the
   potential input values. In response to determining that each rule specification in a set
   of rule specifications will generate at least one output, determining that the set of rule
   specifications is valid. In response to determining that the rule specification is not
20 valid, communicating to a source of the rule specification that the rule specification is
   not valid.
   [0008] Updating the transform includes confirming that the rule specification is valid,
   generating a new transform based on the new or edited rule specification,
   disassociating the first transform from the component, and associating the new
25 transform with the component. Updating the transform includes confirming that the
   rule specification is valid, waiting for the graph-based computation to be executed,
   when the component is activated, generating a new transform based on the new or
   edited rule specification, and associating the new transform with the component.
   Generating the transform includes converting each of a plurality of rule cases in the
30 rule specification to a logical expression to form a plurality of logical expressions, and
   compiling the plurality of logical expressions into computer-executable code.
   Compiling the plurality of logical expressions includes one or more of combining
   expressions, optimizing individual expressions, and optimizing groups of expressions.
   Compiling the plurality of logical expressions includes associating the expressions
35 with components suitable for use in the graph-based computation.
                                                 3

   WO 2008/124319                                                            PCT/US2008/058360
 5 [0009] In general, in one aspect, a computation is tested by receiving a rule
   specification including a set of rule cases, each rule case including a relationship for
   potential inputs and a corresponding output, receiving a set of test cases, each test
   case containing a value for one or more of the potential inputs, and for each test case,
   identifying one of the rule cases that will generate an output given the input values of
10 the test case.
   [0010] Implementations may include one or more of the following features.
   [0011] In response to identifying a rule case that will generate an output for each test
   case, storing or outputting an indication that the rule specification is valid. In response
   to identifying a rule case that will generate an output for each test case, storing or
15 outputting an indication of the output that will be generated. Receiving the set of test
   cases includes receiving a table including a set of test columns, each test column
   containing the value for the one or more of the potential inputs for a corresponding
   one of the test cases. For each test case and the identified rule case for that test case,
   indicating what output will be generated by the identified rule case. For each test case
20 and the identified rule case for that test data set, identifying one or more of the input
   values in the test case as having caused the identified rule case to generate an output.
   also including for each test case, indicating for each rule case which relationships of
   that rule case were satisfied by the values in the test case and which were not.
   [0012] The rule cases have an order, and the identified rule case for each test case
25 corresponds to the first rule case in the order for which each of the relationships for
   the potential inputs is satisfied. Receiving a second rule specification including a
   second set of rule cases, one or more of the rule cases including a relationship for one
   or more outputs of the first rule specification and a corresponding output of the
   second rule specification. For each test case, identifying one of the rule cases of the
30 second rule specification that will generate an output given the input values of the test
   case and the output of the identified rule case of the first rule specification. For each
   test case, generating a graphical display of interrelationships between inputs and
   outputs of the first and second rule specifications that will result in the generation of
   the second rule specification's output. Indicating, for each test case, each rule case
35 that will generate an output given the input values of the test case. Indicating, for each
                                                 4

   WO 2008/124319                                                             PCT/US2008/058360
 5 rule case, how many of the test cases have values for the potential inputs that will
   cause that rule case to generate an output.
   [0013] Each of the test cases includes an output. Determining whether the output
   generated by the identified rule case will match the output included in the test case,
   and storing or communicating the results of the determination. Generating a table
10 including a results row for each test case, each results row indicating the output that
   will be generated by the rule specification given the input values of the test case. In
   each results row, indicating whether the output that will be generated is changed from
   an output that was indicated for a previous version of the rule specification. In
   response to a user interaction with a results row, indicating the identified rule case that
15 will generate the output in that results row. For one of the test cases, generating a table
   including an evaluation row corresponding to each rule case of the rule specification,
   in each evaluation row of the table, for each potential input, indicating whether the
   value for that potential input in the test case satisfied the relationship for that potential
   input in the rule case corresponding to that evaluation row. In an evaluation row of the
20 table corresponding to the identified rule case for the test case, indicating the output
   that will be generated by that rule case.
   [0014] The evaluation rows have an order corresponding to an order of the rule cases
   within the rule specification, and the evaluation row in which the output is indicated
   corresponds to the first rule case for which each of the relationships for the potential
25 inputs is satisfied. Indicating an output that will be generated in each evaluation row
   that corresponds to a rule case for which each of the relationships for the potential
   inputs is satisfied by the test case. Receiving a second rule specification including a
   second set of rule cases, and for each test case, indicating an output that will be
   generated by each rule specification. Generating a table including a results row for
30 each test case, each results row indicating each output generated by a rule
   specification given the input values of the test case. In response to user interaction
   with an indicated output in a results row, indicating which rule case will generate the
   indicated output. The indicated rule case is from the second rule specification, and
   indicating the indicated rule case includes indicating a rule case from the first rule
35 specification and an output of that rule case that satisfies an input relationship of the
   indicated rule case. Receiving the set of test cases includes receiving from a user a set
                                                 5

   WO 2008/124319                                                           PCT/US2008/058360
 5 of input values, matching the set of input values to the potential input values of the
   rule specification, and storing the set of input values to a column of a table. The
   receiving of a set of input values is in response to displaying identifications of the
   potential input values.
   [0015] In general, in one aspect, a component in a graph-based computation having
10 data processing components connected by linking elements representing data flows,
   the component including a transform for transforming data based on a rule
   specification including a set of rule cases, each rule case including a relationship for
   potential inputs and a corresponding output, is tested by executing the graph-based
   computation on a set of input data in an execution environment, logging the input data
15 and the output produced by the computation for each item of data in the set of input
   data, and in a testing environment separate from the execution environment, for each
   item of data in the logged set of input data, identifying one of the rule cases that
   would generate the logged output given the input values in the item.
   [0016] The details of one or more embodiments of the invention are set forth in the
20 accompanying drawings and the description below. Other features, objects, and
   advantages of the invention will be apparent from the description and drawings, and
   from the claims.
                              DESCRIPTION OF DRAWINGS
   [0017] Figure 1A is an example of a transform.
25 [0018] Figure lB is an example of a graph.
   [0019] Figure IC is a block diagram of transform generation and updating.
   [0020] Figure 2A is an example of spreadsheet-based rule entry.
   [0021] Figure 2B is an example of a individual rules.
   [0022] Figure 3 is a test dataset.
30 [0023] Figure 4A is test results.
   [0024] Figure 4B and 4C are details of test results.
                                                 6

   WO 2008/124319                                                             PCT/US2008/058360
 5  [0025] Figures 5 and 7 are flow charts.
    [0026] Figure 6 is an example transform code.
                                  DETAILED DESCRIPTION
    [0027] A business rule can be expressed as a set of criteria that can be used, for
   example, for converting data from one format to another, making determinations
10 about data, or generating new data based on a set of input data. For example, in figure
    1A, a record 102 in a flight reservation system indicates the name 104 of a passenger,
   how many miles 106 he has flown this year, the class 108 of his ticket, and the row
    110 he is seated in. A business rule indicates that such a passenger should be put in
   boarding group 1. A business rule is generally easy for a human to understand, i.e.,
15 "first class passengers are in group 1," but may need to be translated into something a
   computer can understand before it can be used to manipulate data. To implement
   business rules in a graph-based computation environment, a transform 112 is
   generated which receives input records, such as record 102, from one or more data
   sources, e.g., input dataset 100, and inserts an output record, e.g., record 114,
20 indicating the passenger's name 104 and which group he is in 118 into an output
   dataset 120. Input and output datasets may also be referred to as data streams. The
   transforms may then be implemented in graph-based computations having data
   processing components connected by linking elements representing data flows. For
   example, the simple computation graph 130 of figure lB takes as input two data sets
25  132, 134 (for example, frequent flier data and flight reservation data), formats the data
   in each set in separate format components 136, 138 so they can be used together, and
   joins them in join component 140 to produce an output data set 142. A transform may
   itself be a graph-based computation, such as that in the graph 130, or may be
   implemented within a component of a graph, such as the individual components 136,
30  138, and 140 of which the graph 130 is composed.
    [0028] To simplify creation of transforms for non-technical users, a tool is provided
   for such users to input a set of business rules, referred to as a rule set, in a format with
   which they are familiar, that tells the computer system what they want the transform
   to do. A rule set is the set of rules that produce a single transform. A rule may be
35 composed of one or more rule cases that compute different values for the rule's output
                                                  7

   WO 2008/124319                                                             PCT/US2008/058360
 5 depending on the input. A rule may also include other rules. Other rules in a rule set
   may produce values for additional or alternative outputs. A rule set may contain other
   rule sets, which we refer to as "included" rule sets.
   [0029] A general model of the transform generation system is shown in figure IC. A
   generator 150 receives as input a rule set 152 from an editor 154 and generates a
10 transform 156. The generated transform 156 may be provided to a graph-based
   computation system 158 as a component to be used in a graph or as an entire graph
   itself, depending on the system's architecture and the purpose of the transform and the
   business rules. The generator 150 may be, for example, a compiler, a custom-built
   program, or another graph-based computation configured using standard tools to
15 receive the rule set 152 and output the transform 156.
   [0030] The generator 150 may also update the transform 156 when the rule set 152 is
   edited. When the rule set 152 is edited, the editor 154 may provide the entire rule set
   to the editor or it may provide only the new or modified rules or rule cases 152a. The
   generator 150 may generate an entirely new transform to replace the original
20 transform 156, or it may provide a component 156a containing the transform,
   depending on the capability and needs of the system using the transform.
   [0031] In some examples, a rule can be entered in a spreadsheet format, as shown in
   figure 2A. Trigger columns 202, 204, 206, 208 in spreadsheet 200 correspond to
   available data values, and rows 210a-h correspond to rule cases, i.e., sets of criteria
25 that relate the available data values. A rule case 210n applies to a given record (e.g.,
   102 in figure 1A) if the data values of that record, for each trigger column in which
   the rule case has criteria, meets the triggering criteria. If a rule case 21 On applies,
   output is generated based on one or more output columns 212. A rule case that has all
   of its input relationships satisfied may be referred to as "triggered." Each output
30 column 212 corresponds to a potential output variable, and the value in the
   corresponding cell of the applicable row 21 On determines the output, if any, for that
   variable. The cell could contain a value that is assigned to the variable or it could
   contain an expression that must be evaluated to generate the output value, as
   discussed below. There may be more than one output column, though only one is
35 shown in figure 2A.
                                                 8

   WO 2008/124319                                                             PCT/US2008/058360
 5 [0032] There may be several different types of trigger columns, including columns
   that correspond to a variable, columns that contain expressions but are calculated once
   and then treated like variables, and columns that only contain expressions. Other
   column types include columns that only contain data and columns that specify an
   expression to evaluate for every row, based on the columns that only contain data.
10 Columns that only contain expressions are simpler than those corresponding to or
   treated as variables. Such columns can contain one of the following:
        *   An expression. The condition will be considered to be true if the evaluation of
            the expression evaluates to a non-zero, non-NULL value.
        *   The keyword "any," or an empty string. The condition is always true. Each
15          empty cell in a trigger column is equivalent to one explicitly containing the
            keyword "any."
        *   The keyword "else." The condition is true if none of the cells above the cell
            containing "else" is true, in rows where all cells to the left are identical.
        *   The keyword "same". The condition is true if the cell above is true.
20 [0033] Columns that correspond to a variable can have two types of cells. One type of
   cell is an expression cell. Those cells behave exactly like cells in a column that
   contains only expressions, described above. However, the keyword "this" can be used
   in the expression to refer to the column variable. The other type of cell is a
   comparison value. An exemplary grammar for comparison values is as follows:
25          comparison-value ::= compound value ( "or" compoundvalue )*
            compound-value ::= simple value ( "and" simple value )*
            simple value ::= [ "not" ] (value expression I simple function I
                membershipexpr )
            value expression ::    [operator ] valueelement
30          operator ::= ">"| "<"| ">="| "<=1 | "!="| "'="| "equals"
            valueelement ::= constant I constant Ivariable | "("expression ")"
            simple function ::= "is-null" "is blank" "is valid" "is defined"|
                "is bzero"
            membershipexpr ::= "in" "[" valueelement        ( ( ","  "to"| "or"  )
35              valueelement )* "]"
                                                9

   WO 2008/124319                                                           PCT/US2008/058360
 5 where a "*" means a term is repeated zero or more times.
   [0034] Any suitable programming language or syntax may be used. Examples may
   include C, Java, DML, or Prolog. The column variable is compared against the
   comparison value according to the operator, function, or membership expression. In
   the example of figure 2A, the first two columns 202 and 204 contain comparison
10 values with the ">=" operator, thus the criteria is met if the value for that column is
   greater than or equal to the corresponding number. If there is no operator, as in the
   "Class of Seat" column, then "equals" is assumed. A constant can be any legal
   constant in whatever programming language or syntax is used in the underlying
   system. The other constants and variable are business terms as defined within the rule
15 set, as described below. A expression is any legal expression in the language being
   used that returns a compatible datatype that will be compared against the column
   variable. In some examples, expressions inside comparison values are enclosed in
   parenthesis to avoid ambiguity. For the simple function, the function is applied to the
   column variable, so the "isnull" keyword is the same as the expression
20 "is null(this)".
   [0035] In the example of figure 2A, the first row 210a has criteria in only one
   column, 202, which indicates that if the total number of frequent flier miles for a
   traveler is greater than 1,000,000, then that rule case applies regardless of what value
   any other columns may have. In that case, the "Boarding Group" output variable for
25 that user is set to group 1. Likewise, the second rule case 21Gb indicates that any flier
   in first class is in group 1. In some examples, the rules are evaluated in order, so a
   traveler having over 1,000,000 miles and a first class ticket will be in group 1, but
   only the first rule case 210a will be triggered. Once a rule case is triggered, the other
   rule cases in that rule do not need to be evaluated.
30 [0036] The next rule case 210c is based on two input values 202 and 204 - if the
   criteria defined for both total frequent flier miles and current-year miles are met, then
   the flier is in group 2. In a fourth rule case 210d, any business class customers are also
   in group 2. The remaining rule cases 21 Ge-h contain criteria that relate to the other
   rule cases, i.e., "else" and "same." As discussed above, "else" indicates that none of
35 the criteria in that column were met in rows that were above that one and which had
   the same criteria to the left (i.e., rules 21Gb and 210d), while "same" indicates that the
                                                  10

   WO 2008/124319                                                            PCT/US2008/058360
 5 rule case applies if the rule case above it applied with respect to that column. Thus,
   the fifth rule case 210e applies to any record that didn't match any criteria in the first
   two columns 202 or 204 (because it would have been handled by rule cases 21 Ga or
   210c), didn't have "first" or "business" in the "class of seat" column (the "else"
   keyword in column 206), and which has a "row of seat" value 208 less than or equal
10 to 10. Each of the remaining rule cases 210 f-h applies to records that also didn't
   match any higher rule case with values in columns 202 or 204, didn't have "first" or
   "business" in the "class of seat" column, and which have the appropriate "row of
   seat" value.
   [0037] The rule cases 21 Ga-h in the example of figure 2A can also be represented as
15 individual simple rules, each in their own spreadsheet, as shown in figure 2B. Rules
   220a-d corresponds to rows 21 0a-d of figure 2A, respectively, while rule 220e has
   four rule cases corresponding to rows 21 Ge-h together. A user could create these
   individual rules separately, rather than generating the entire table shown in figure 2A.
   Each rule case contains a value for every trigger column and a value for every output
20 column (the value can be blank, i.e., effectively set to "any"). When multiple rules
   generate the same output, the rules are ordered and they are considered in order until a
   rule case in one rule triggers on the inputs and generates an output. If no rule case in a
   rule triggers, the next rule that produces the same output is processed. If no cases in
   any rule trigger for an output, a default value is used.
25 [0038] In some examples, the editor interface may graphically identify cells that
   contain expressions. This will help the user understand the difference between an
   expression that will be evaluated to true or false on its own and an expression that
   returns a value that is compared against the column variable. When the user is typing,
   he can indicate that a particular cell is to be an expression cell by, for example, typing
30 an asterisk at the beginning.
   [0039] In some examples, values and expressions are DML expressions. The full
   DML language can be supported. The special keywords and the business names for
   fields and values are encoded as strings that are pre-processed out of the DML
   expressions. Note that the expressions can use the logical (business) names for
35 variables, but can also refer to the actual physical names, though this may interfere
   with testing.
                                                 11

   WO 2008/124319                                                               PCT/US2008/058360
 5 [0040] For columns that correspond to output variables, the cells can contain one of
   the following:
        *   A value. The value that will be assigned to the output variable
        *   An expression. The value of the expression is assigned to the output variable.
            If the expression evaluates to NULL then the field gets the NULL value,
10          unless the output field is not-nullable. In which case, an error is generated.
        *   The keyword "null". If the output field is nullable, then the field will be
            assigned NULL. Otherwise, an error is generated.
        *   An empty string. If the output field has a default value, then the default value
            is assigned. Otherwise, the cell is treated as if it contains the keyword "null".
15      .   The keyword "same". The output field is assigned the same value computed in
            the cell above.
   [0041] If possible, errors are reported as soon as possible (i.e. putting "null" in an
   output column for a non-nullable field). However, some errors cannot be reported
   until either test-time or run-time.
20 [0042] In addition to expressions, users may be allowed to attach comments to any
   cell in the rule. The comments can be displayed just like comments attached to cells in
   common spreadsheet programs such as Microsoft Excel.
   [0043] In some examples, the rules editor interface may be configured to restrict what
   a user may enter more tightly than the technical requirements of the interface would
25 require. For example, the interface may be configured to only allow certain types of
   variables or certain types of expressions in order to provide a simpler, more
   constrained user interface. The interface may also be configured to restrict which cells
   in a rule can be changed, based on a user's role or user ID. Such restrictions may be
   applied to a Rule set by an administrator.
30 [0044] Whether created as rows of a table or as individual rules, each rule has a
   certain set of attributes. Rule sets may determine these attributes for the rules they
   include. These attributes may include a name, a rule type, a description and comment
   field, a list of output variables, a list of input variables, a list of arguments, a list of
   trigger columns, a modification history, a test dataset, and an error handling behavior.
                                                   12

   WO 2008/124319                                                             PCT/US2008/058360
 5 A name is self-explanatory, and is used for listing the rule in a rule set. A rule type
   may be, for example, "normal" or "function." In some examples, the rule type is a
   property of the rule set. The list of output variables is the set of variables produced or
   assigned values by the rule. This may be inherited from the rule set, and there can be
   one or more outputs. The list of input variables identifies all the variables that the rule
10 needs to evaluate a record, including those at the top of the columns and those used
   inside expressions (for example, the "last year frequent flyer miles" value used in rule
   210c in figure 2A is used in an expression but does not have its own column).
   [0045] In some examples, multiple rule cases may be used to generate multiple output
   records for a single input record. Such a rule set is referred to as a normalize rule set.
15 In a normalize rule set, one of the outputs is identified as a key output. When the rules
   that compute the key output are evaluated, the rule case that triggered on the input and
   generated output is noted. The rules are then evaluated again, with the previously
   triggered rule case disabled, to see if any other rule cases trigger and produce an
   output. This is repeated until no rule cases trigger. Each output may be stored as a
20 separate output record. In some examples, rule cases are grouped, such that if one
   triggers, others in its group are also disabled on the next iteration for the same input.
   [0046] In some examples, rules may be evaluated in a manner converse to that
   described above, with rule cases in rows being ANDed and columns being ORed. That
   is, a rule produces an output only if every row triggers (ANDing the rows) but only a
25 single cell needs to be true for each row to trigger (ORing the columns).
   [0047] The list of arguments is only present for function rules. It identifies the names
   and types of parameters that are inputs to the rule, and may be a property of the rule
   set. The list of trigger columns identifies which columns may trigger application of
   the rule. Beyond just the input variables shown in the example of figures 2A and 2B,
30 trigger columns could correspond to parameters, lookup variables, output variables
   from an earlier rule, output variables of included rule sets, parameters to the rule set,
   or expressions. They may also include input variables from function rules, i.e.,
   arguments.
                                                 13

   WO 2008/124319                                                              PCT/US2008/058360
 5 [0048] The modification history includes modification names, dates, and comments.
   In some examples, there is one modification history for each rule, and one for each
   test set (discussed below).
   [0049] Error handling determines how the transform created from the rule set handles
   errors that occur when evaluating a rule. For handling errors in a trigger expression,
10 the options are to allow the error, in which case the transform rejects the record that
   caused the error, or to ignore an error, which is equivalent to assuming the trigger
   expression to be false and moving on to the next rule. For output expressions, errors
   can be handled by to allowing the error and rejecting the record, ignoring the error
   and setting the output to NULL, or ignoring the row in the rule and moving on to the
15 next row.
   Test Data
   [0050] To assist in evaluating whether a rule set will work as intended, it may include
   a test dataset. The test dataset for a rule set is a set of prototypical inputs and expected
   outputs, for example, as shown in figure 3. The test dataset consists of a spreadsheet
20 like table 400 with one row 402a-e for each field being referenced by the rules and
   one row 404 for each output (in this example, there is only one). The user then creates
   test cases represented in columns 406a-r of test data and expected results. This test
   data may be saved with the rule. The example of figure 3 contains possible inputs
   402a-e and intended outputs 404 for the rules of figures 2A-B. For various
25 combinations 406 of frequent flyer miles and seating assignments, it shows what
   boarding group 404 should be calculated (there are many more combinations of
   possible inputs than are shown). In some examples, the test input includes a value vor
   every variable in every lookup. Test input may also include a value for every
   parameter and a value to use as "now" for any rules that reference the current date or
30 time. For testing individual units, the test input may include a value for any included
   rule set, so that included rule sets do not have to be evaluated when the including rule
   set is tested.
   [0051] In some examples, the columns 402, 404 in the unit test table are determined
   by the software based on user action. When the user edits a rule, the rule's details are
35 parsed and a definitive list of referenced input variables is generated. This list
                                                  14

   WO 2008/124319                                                           PCT/US2008/058360
 5 includes variables used in column headings and variables embedded in expressions.
   One column is generated for each variable, each technical variable embedded in an
   expression, and each lookup expression. In some examples, a user creates a test table
   400 by providing test cases one at a time. For example, the user may specify that a
   customer with 2,000,000 total frequent flyer miles, 200,000 miles this year, 150,000
10 last year, and a first class ticket in row 5 should be in boarding group 1. The software
   determines which of rows 402a-e and 404 correspond to these inputs and outputs and
   creates a corresponding column 406a in the table 400. This can be repeated for as
   many test cases as a user wishes to enter. In some cases, the software may provide an
   interface offering each potential input or output variable to the user so that the user
15 can merely enter or select values without having to know what variables need them.
   [0052] The user can then fill in test cases and execute a test. At that point, the
   software evaluates the rule for each line of the test dataset table and computes the
   resulting value. If the resulting value matches the expected value (the value entered by
   the user in the column corresponding to the output variable), an indication is given
20 that the rule is valid, for example, the output cell may be shown in green. If the
   resulting value does not match the expected value, this is indicated, for example, the
   cell may be shown in red and both the expected and the actual value are displayed.
   The user can then update the test case or fix the rule. Other user interface mechanisms
   can of course be used. For example, rather than comparing computed outputs to input
25 expected outputs, the test procedure may simply display what the computed output
   would be, and let the user evaluate whether that is correct.
   [0053] In some examples, users have real data that they can use for generating test
   data. The ultimate users of the business rules may provide such data to the developers
   to use in testing. To handle cases where the users do not have real data to test with, the
30 software may provide a simple data entry form for entering test data one record at a
   time. The user can type in values for each of the fields in the input dataset and those
   records will be added to the identified test dataset.
   [0054] In some examples, rules are validated as they are entered, and a rule that does
   not produce the expected output can be identified immediately in the interface,
35 similarly to how a word processor may mark misspelled words as they are entered.
                                                  15

   WO 2008/124319                                                             PCT/US2008/058360
 5 [0055] In some examples, after a test has been performed, the user can select any row
   (test case) in the test dataset table. If a row is selected, the corresponding row in the
   rules table that produced output for that test case will be displayed. In addition to
   expressions, users can attach comments to any cell in the test dataset table.
   More on Rule Sets
10 [0056] As noted above, a transform is generated from a rule set. A rule set may have
   the following attributes:
   [0057] A name, description, and comments - these help to identify a rule set.
   Depending on the back-end implementation, a rule set may include an identification
   of its location within the system. In some examples, a rule set's location is a path in a
15 project. In some examples, rule sets may be organized in a relational database and
   located by name. A modification history includes modification names, dates, and
   check-in comments.
   [0058] A transform type - this determines what type of transform is generated from
   the rule set. Possible values include reformat, join, rollup, and filter, as discussed
20 below.
   [0059] Input datasets - these provide a list of fields and named constants for editing.
   In some examples, when the transform is generated it will assume the record format
   of one of the input datasets by default. There may be multiple input datasets, allowing
   the rule set to generate transforms for different environments. This also allows
25 multiple sets of logical to physical mappings, i.e., different sets fo physical names. In
   some examples, there in an input mapping table with one or more datasets. In some
   examples, a join component may have multiple input mapping tables, and each may
   have multiple datasets.
   [0060] Output datasets - these provide a list of output field names. By default, when
30 the transform is generated it will assume the record format of one of the output
   datasets. The output dataset can be the same as the input dataset. Included rule sets
   will not have an output dataset. In some examples, as with input datasets, there are
   multiple output datasets, allowing the rule set to generate transforms for different
   environments.
                                                  16

   WO 2008/124319                                                             PCT/US2008/058360
 5 [0061] A list of included rule sets - one rule set can use the output fields computed by
   another rule set (explicitly listed output fields, not fields of the output record format).
   Output variables in the included rule sets may be used as variables in the including
   rule set, based on an included rule set mapping table that defines the set of output
   variables from an included rule set that are visible in the including rule set.
10 [0062] A list of included transform files - one or more files that specify transforms to
   be used when processing a rule set can optionally be included.
   [0063] A series of mapping tables that list the variables and constants - these tables
   are intertwined with the input and output datasets. They make the list of variables
   known to the editor and document the mapping between business names and technical
15 (DML) names. Each variable has a business name, technical name (DML
   expressions), and base type (string, number, date or datetime). Associated with each
   variable is an optional list of constants that documents the mapping between business
   name and DML constant value. The variable tables are described in more detail below.
   [0064] References to external test data files - Test files are used for testing the rules,
20 similarly to the embedded test datasets discussed above.
   [0065] A No-reject flag - if this flag is set, then the transform produced by the rule set
   will not reject records (throw errors). This may be used so that a rule that throws an
   error will be ignored, as if that rule never triggered.
   [0066] A deployment table - this lists one or more deployments, which indicate
25 (indirectly) which rules should be included in each build. The deployment table is
   described in more detail later.
   [0067] An optional key - this lets users specify the business name of a special input
   field that represents the key for join-type and rollup-type rule sets. In some examples,
   the key is actually implemented as an entry in the table of input variables, with a type
30 of key.
   [0068] An optional list of lookup files - this provides business names, key
   information and a complete table of input variables and constants, one table per
   lookup file. Lookup file support is described in more detail below.
                                                 17

   WO 2008/124319                                                           PCT/US2008/058360
 5 [0069] A table of parameters - this lists variables whose value comes from the
   environment or from a parameter set at run-time.
   Tables of variables and constants
   [0070] As noted, each rule set has an associated set of tables of variables and
   constants. In some examples, these tables are private to the rule set and cannot be
10 shared between rule sets. The tables of variables and constants are used for several
   purposes:
           1. As the definitive list of input variables used by the rule set and output
               variables produced computed by the rule set.
          2. As a list of business names available during editing. While editing, the
15             system will present a suggested list of business names for variables and for
               constants. This list comes from the tables of variables and constants.
          3. As a mapping table to translate business names to technical names. The
               rules will include business names (in text, inside of DML pre-processor
               directives as described later). When the transform is created, the business
20             names get replaced by technical names or DML expressions. Some of the
               tables, like the input variables and the output variables, can have multiple
               datasets each with different technical names for the business names. The
               translation used depends on the deployment (detailed later).
   [0071] A rule set will have several different tables. The tables are similar in most
25 ways but there are some slight differences. The tables include:
           1. A table of input variables and constants. For transform-type rule sets, this
               table contains the fields in the input record format that will be referenced
               in the rules. Not every field in the record format needs to be listed, but
               they usually are. With a Join-type rule set, there will be multiple input
30             tables, with each table representing one input dataset for the join operation.
          2. A table of input variables and constants for all included rule sets. When
               using included rule sets, each included rule set has its own table of input
               variables and constants. When a transform is built, the input variables used
               by included rule sets must be mapped to actual inputs in the context of the
35             rule set doing the including. Therefore, this list is promoted to the
                                                 18

   WO 2008/124319                                                            PCT/US2008/058360
 5             including rule set. If multiple included rule sets are included, each input
               variable table is promoted. (If an included rule set itself includes a rule set,
               the second-level variables are not promoted.) Input variables and constants
               promoted from included rule sets are not available for use in the including
               rule set. This table is only included so a mapping can be established
10             between the inputs to the included rule sets and the inputs to the including
               rule set. See below for more detail.
            3. A table of output variables and constants for all included rule sets. When
               rule sets have been included, the outputs of those included rule sets
               become inputs to the including rule set. This table lists all those variables.
15             It is initially populated directly from the table of output variables and
               constants in all the included rule sets; however, the business names can be
               changed to avoid name collision. For this table, the technical name is
               really the business name inside the included rule set.
            4. A table of output variables and constants. For transform-type rule sets, this
20             table contains the fields in the output record format that will be calculated
               by the rule set. Output variables that are not calculated can also be
               included and will be ignored by the rule set. (The generated transforms
               have a wildcard rule to copy inputs to outputs. In addition, the outputs
               could have default values included.)
25                  Output variables can also be used as intermediate variables, meaning
               the value of an output produced from one rule can be referenced in a later
               rule. Sometimes the output is only used in this way; it is never directly
               included in the output record from the transform.
            5. A table of parameters. rules may include references to parameters.
30             Parameters are resolved at runtime in the context of a graph's parameter
               set. Like other variables, in a rule set a parameter has a business name, a
               technical name (e.g., $RUNDATE) and a type.
            6. A table of variable mappings for each lookup file. These are similar to the
               input tables, but map to fields in the record format for the lookup file.
35 [0072] Non-shared rule sets (which are designed to produce transforms) are usually
   tied to both input and output datasets. The input dataset is the source of input
                                                 19

   WO 2008/124319                                                            PCT/US2008/058360
 5 variables. The output dataset is the source of output variables. Sometimes a rule set
   will have multiple input datasets and/or multiple output datasets. In that case, each
   input dataset and output dataset is a possible input or output of the transform. There
   will only be one set of input variables (except for join operations), but there may be a
   different mapping between business names and technical names for the different
10 datasets. In some cases, an input variable may be used by the rule set and be present
   in one input dataset but not in a second input dataset. In that case, a DML expression
   must be specified as the technical name of the missing variable in the second input
   dataset. If the rule set does not use an input variable, there is no need to supply a
   technical name for every input dataset.
15 [0073] Likewise, there may only be one set of output variables. If a given output
   dataset does not have field corresponding to an output variable (i.e. there is no
   technical name), then that output will be ignored when generating the transform for
   that output dataset.
   [0074] Included rule sets are treated somewhat differently. Included rule sets do not
20 have associated input and output datasets. Instead, they just have input variables and
   output variables. The rule set that includes a included rule set is responsible for
   mapping the input and outputs. This is described in more detail later.
   Variables
   [0075] Variables may have the following properties, and may be presented to the user
25 in tabular form:
           1. The business name (logical name). The business name is the name used in
                rules. In some examples, restrictions are imposed such that no two input
                variables can have the same name, no two output variables can have the
                same name, no two outputs from included rule sets can have the same
30              name, and no two lookup variables in the same lookup file can have the
                same name. An input variable can have the same name as an output
                variable. In such a case, the user interface may disambiguate the input and
                output based on context or by using a prefix such as "out." in front of the
                output variable name. Lookup variables in different lookups file can have
                                                 20

   WO 2008/124319                                                           PCT/US2008/058360
 5            the same name. In that case, using a prefix such as the name of the lookup
              file itself will disambiguate them.
          2. A simple type. In some examples, four basic types may be supported
              string, number, date and datetime. These correspond to DML types
              string(int), decimal(20), date("YYYY-MM-DD") and datetime("YYYY
10            MM-DD HH24:MI:SS.nnnnnn"). Conversion between the basic type and
              the actual type used in the transform will be handled separately from the
              editing of the business rules, for example, by the generated transform
              component.
          3. A default value. The default value is only needed for output variables. This
15            is the value that is used when (1) there is an empty cell in an output
              column in a rule for that output, or (2) when no rules trigger to compute a
              value for that output. Default values can be NULL (and an empty cell is
              interpreted as NULL), as long as the output variable is nullable.
                   Default values are expressions, just like the expressions that are used in
20            output columns in a rule expression table. This means that default values
              can refer to input variables or output constants or contain expressions.
              Default values can also refer to other outputs, as long as no circularities are
              introduced.
          4. A technical name (physical name) or expression. This is the expression
25            that specifies the variable. It is possible to use a expression instead of a
              field name for input and included variables (in some examples, using
              expressions is not allowed for output variables). In the case of vectors, the
              expression should be fully qualified.
                   When dealing with prompted variables and input and output variables
30            from included rule sets, the technical name associated with a variable is
              really just the business name used inside the shared rule set. When dealing
              with output variables that are only used internally (intermediate variables
              computed in one rule and used in a subsequent rule), the technical name
              can be blank.
35        5. An optional description and comment.
                                                 21

   WO 2008/124319                                                            PCT/US2008/058360
 5 Constants
   [0076] The various tables of variables include mapping for constants as well as
   variables. Constants correspond to enums in C++. The software may support constant
   values that initially come from valid values and invalid values, and constant ranges
   that initially come from valid and invalid ranges. Additionally, it is possible to create
10 constants that represent sets of distinct values and/or ranges.
   [0077] Constants are associated with variables. This means that the business names of
   constants do not have to be unique across the entire rule set. The editor will normally
   know the context for any constant based on which column in the rule the constant
   appears in; however, it is possible for the user to select a constant belonging to a
15 different variable in expressions. In that case, the constant will be qualified with the
   variable name (e.g., "Airline class.business").
   [0078] When computing output variables, only single value constants are used (it
   makes no sense to assign a range to an output field).
   [0079] Constants have the following properties, and will be presented to the user in
20 tabular form. (variables and constants may be intermingled, similarly to embedding a
   table inside another table.)
            1. The variable name. All constants apply to exactly one variable. The
                variable name is actually part of the associated variable itself.
            2. The business name. The business name is the name used in rules. The
25              name does not have to be a value identifier, specifically, internal spaces
                and punctuation are allowed. Business names for constants only have to be
                unique within the variable they apply to.
            3.  The constant type. One of value, range, or set. As mentioned earlier, ranges
                and sets are only legal when used in comparisons (inputs), not in
30              assignments (outputs).
            4. For values: the actual value. In the present example, strings should be in
                quotes and numbers should not be. Dates and date-times should be in
                quotes in the default forms (e.g., "YYYY-MM-DD"). Using an expression
                is also allowed as long as that expression returns a simple type that can be
                                                 22

   WO 2008/124319                                                            PCT/US2008/058360
 5             automatically converted to the variable type.
                   When a constant is part of the table of inputs or outputs for an included
               rule set, there is no value. Instead, the value is the business name of the
               associated constant for the corresponding input or output variable.
           5. For ranges: the minimum and maximum values. Both are constants or
10             expressions, just like the actual value documented above. Ranges are used
               as shorthand for comparison in rules. Only equality comparisons are
               allowed for ranges, and the software will translate ranges into "variable >=
               minimum and variable <= maximum". If the minimum is not specified,
               that part of the comparison will be skipped. Likewise for the maximum.
15             The range is actually stored with a comma separating the minimum and
               maximum values.
           6. For sets: a comma separated list of the values. Each element of the list is a
               constant or expression, just like the actual value documented above. Only
               equality comparisons are allowed for sets, and the software will translate
20             sets into an expression in the form of "variable member of [vector list of
               values ]".
           7. An optional description and comment.
   [0080] When dealing with promoted variables from shared rule sets, constants are
   also promoted. In the tables that show the input and output variables for shared rule
25 sets, constants associated with those variables are also shown. The default mapping
   for those constants is part of the promoted information, but the user can override the
   constant values.
   [0081] The software will detect when there is a possible conflict in the use of
   variables because of mismatching constants. Specifically, if (1) the value of any
30 variable is copied into another variable, and (2) if both variables have constants
   defined, and (3) the set of constants are not identical in both name and value, then an
   error will be generated that the user needs to translate the value of one variable into
   the values of the other. Source variables include input variables, lookup variables,
   outputs from included rule sets, and output variables used as inputs. Target variables
35 include output variables and inputs to included rule sets. Assignment can happen in
   rule expressions or in variable tables.
                                                 23

   WO 2008/124319                                                            PCT/US2008/058360
 5 Naming Restrictions
   [0082] All things that can be used as inputs generally need to have names that are
   unique within the entire rule set. This includes business names of input variables,
   business names of parameters, and business names mapped to the outputs of every
   included rule set. For join operations, input variables in different sets of inputs can
10 have the same names. They may be disambiguated, for example, with a prefix
   corresponding to a business name for the input set.
   [0083] Output variables also have to be unique. However, output variables may have
   the same name as input variables. If an output variable has the same name as an input
   variable, and the variable name is used in a place where input variable names are
15 allowed (like in a trigger column for a rule), then the input variable is assumed. To use
   the output variable instead, the name needs to be qualified, for example, by entering
   "out.<variable-name>" when entering the variable name. This is interface notation
   only - the internal representation of variables is unambiguous.
   [0084] There can still be ambiguity between variables and constants that have the
20 same name. In that case, the software will favor a constant when in a context where
   both a constant and a variable with the same name make sense. The user can override
   that by qualifying the variable name using, for example, the syntax "in.<variable
   name>."
   [0085] In some examples, business names are assumed to be in UTF-8 so they can
25 include international characters. Business names can include spaces, periods,
   parenthesis, etc. However, in such an example, business names are not allowed to
   include any character between OxO and 0x31 (the control characters). All business
   name matching is case sensitive, though the user interface may allow the user to enter
   business names with the wrong capitalization and then suggest the correct
30 capitalization, for example using an auto-complete mechanism
   Ordering of Variables
   [0086] To avoid circular logic, the software enforces a strict ordering of variables and
   rules. The global ordering is as follows:
           1. Input variables and Parameters.
                                               24

   WO 2008/124319                                                            PCT/US2008/058360
 5         2. The 1st included rule set's input mappings.
           3.   The 1st included rule set's output values.
           4. The Nth included rule set's input mappings.
           5. The Nth included rule set's output values.
10         6. The 1st lookup file's default key values.
           7. The 1st lookup file's output fields.
            8. The Nth lookup file's default key values.
           9. The Nth lookup file's output fields.
15          10. All output variables' default values.
   [0087] The calculation of each item uses values computed in previous steps. This
   means, for example, that the first included rule could refer to input variables and
   parameters in its mapping table. The second included rule, however, could map its
   inputs to outputs computed from the first included rule. Similarly, the default values
20 for each output variable are computed before any rules, so they are based on the
   values of input variables, parameters, lookup files, or outputs from any included rules.
   When it comes time to actually calculate the output of the rules, the rules are
   evaluated in order so later rules can use the values computed from earlier rules.
   Linking Datasets to Variables
25 [0088] In some examples, the table of input variables comes directly from the input
   dataset record format and the business names come from the metadata on the input
   dataset. However, in some examples, there are advantages to having a copy of this
   mapping inside the rule set. First, having a copy of the variables mapping table in the
   rule set makes it possible to edit the rule set outside the context of the production
30 environment. The rule set and associated rules could be serialized into a sandbox and
   edited as part of a sandbox project. Second, having a copy of the input variables
   mapping table makes it possible for the user to resolve conflicts or otherwise override
   the existing metadata. For example, if two fields in the input dataset map to the same
                                                25

   WO 2008/124319                                                             PCT/US2008/058360
 5 business name, one of those business names could be changed in the table of input
   variables.
   [0089] When a rule set is first created, the input variable table is empty. As soon as
   the user identifies the input dataset, the input variable table is populated,
   automatically, from the metadata of the input dataset. (The same logic applies to the
10 output variables and output dataset, but the rest of this discussion will focus on the
   input dataset for simplicity.)
   [0090] The singular term "input dataset" is used in this description for simplicity.
   There are zero or more input datasets that can be linked to input variables, and a
   separate set of zero or more input datasets that can be linked to output datasets.
15 Specifically, the input variable table has one column for the business name, one
   column for the type, etc. and many columns for the technical names, one per input
   dataset. Once a single input data set is specified, a second can be added using similar
   technique. However, in the case of a second or subsequent dataset the mapping
   between technical name and business name may be less complete, especially since the
20 system may not be able to figure out which variable each field in the second and
   subsequent dataset maps to. In such examples, the user can manually correct any
   missing information.
   [0091] When initially creating the input table from an input dataset, each field in the
   input dataset will cause one input variable to be created. The technical name for the
25 input variable will be the name of the field. The type will be assigned based on the
   field type. Voids will be treated like strings, reals will be treated like numbers.
   Subrecords will not have corresponding input variables although the fields inside
   subrecords will. Unions will result in input variables for each branch of the union. If
   an element is a vector, the technical name of the corresponding input variable will
30 assume the first element of the vector ("in.vect[O]"). The user can override this. For
   example, in the normalize-type transform, the user may change the technical name to
   be in.vect[index]. Or, the user may create additional input variables corresponding to
   other elements of the vector, if the vector is fixed length. Unions and vectors may not
   be supported in output datasets (no output variables will be created for them). In some
35 examples, a variation of the normalize component may output an output bector
   instead of multiple output records.
                                                26

   WO 2008/124319                                                            PCT/US2008/058360
 5 [0092] In some examples, the business name is computed from the metadata. The
   logic for determining the business name for a field is as follows:
            1. If the field (Physical Element) has a display name, then the display name
               of the field is used as the business name.
            2. Otherwise, if the field has a Logical Element and the Logical Element has
10             a display name, the display name of the Logical Element is used as the
               business name.
            3. Otherwise, if the field has a Logical Element, the name of the Logical
               Element is used as the business name.
            4. Otherwise, a business name is computed from the technical name.
15 [0093] If there is a conflict (duplicate name), then only one business name will be
   assigned. The other fields will not be assigned any business name.
   [0094] In some examples, there is no dynamic linking between rule sets and dataset
   metadata. If users change the metadata data (for example, renaming a Logical
   Element), that change is not automatically picked up by the software. In some
20 examples, a two-way relationship between data may be used to allow such changes to
   be detected.
   [0095] If a user adds a second dataset to rule set, the software will try to fill in fields
   for each of the business names using the same physical to logical mapping rules as
   listed above. If a variable cannot be mapped, the technical term for that variable will
25 be left blank for the added dataset and the user will have to fill in a field name or
   expression manually. Available fields will be listed in a pull-down in the user
   interface.
   [0096] At the same time that the input variable table is created from the dataset
   metadata, constants may be added to the input variable table, also from the dataset
30 metadata. The software will create constants for all valid and invalid values and all
   valid and invalid ranges associated with the Validation Spec associated with each
   Logical or Physical Element.
                                                27

   WO 2008/124319                                                               PCT/US2008/058360
 5 [0097] The logic for determining the business name for a constant is as follows:
            1. If the valid value (valid range, etc) has a display name, the display name
                will be used as the business name.
           2. Otherwise, if the valid value (valid range, etc.) has a description, the
                description will be used as the business name.
10         3.   Otherwise, the constant will be included in the variable table without a
                business name.
   [0098] It is not necessary to create variables starting with datasets. A second way to
   create a list of input variables is to identify a Logical Entity in the underlying system.
   If a Logical Entity is selected, then the software will create a table of variables with
15 one variable for each Logical Element in the Logical Entity. The business names of
   the variables will be the displayname of the Logical Elements. If the Logical
   Elements have Validations Specs, constants will also be created using the previous
   document rules.
   [0099] Finally, input and output variables can be added manually, either by adding
20 them to them the variable table or by creating them while editing rules. For example,
   when a user adds a column to a rule, he selects which input variable should be used
   for that column. But he can also select "new..." and create an input variable on the
   fly. The software will then prompt the user for a datatype and optional comment. No
   technical name needs to be filled in until later.
25 [0100] The software needs a list of variables in order to allow rules to be edited.
   However, the mapping between business names and technical names does not have to
   be completed until later. The mapping is only needed when the user is ready to either
   test the entire rule set against an external test file or actually create a transform from
   the rule set.
30 Included Rule Sets
   [0101] In some examples, rule sets can be shared. Specifically, an included rule set is
   designed to be included inside another rule set so that its logic becomes part of the
   including rule set's generated transform.
                                                  28

   WO 2008/124319                                                           PCT/US2008/058360
 5 [0102] Although included rules sets are usually designed specifically to be shared, a
   included rule set can also be used standalone to create a transform. For example, a
   user could create a rule set that computes a Boolean output for a filter-type transform.
   But at the same time, that rule set could be included inside another transform and the
   Boolean output (an output variable of the shared rule set, available in the including
10 rule set) could be used to compute a more complex output.
   [0103] Included rule sets are similar to other types of rule sets. They have input
   variables and output variables. And they can, themselves, include other included rule
   sets. But the handling of input and output variables in included rule sets is different
   than with transform-type rule sets. In transform-type rule sets, the input and output
15 variables are mapped to technical names so a transform can be generated. But in
   included rule sets, there is no need to map input and output variables to technical
   names. (If a rule set is both shared and used to generate a transform, then the inputs
   and output variables will be mapped to technical names for the deployments that
   generate a transform.)
20 [0104] When a user includes a included rule set into another rule set, the including
   rule set needs to have variable mapping tables to map the inputs and outputs of the
   included rule set. In the context of the including rule set, only the input variables and
   output variables of the shared rule set are visible. Any variables of any rule sets
   included in the shared rule set are not exposed to the including rule set.
25 [0105] In the context of the including rule set, the input variables of the shared rule
   set need to be mapped to variables of the including rule set, or expressions using those
   variables. The business names of the shared rule set will be listed in a variable
   mapping table, but those names will not be available to be used in rules in the
   including rule set. Instead, the including rule set only needs to match each input
30 variable (by business name) of shared rule set to an expression in the including rule
   set.
   [0106] Included rule sets are considered to be evaluated before input variables,
   parameters and lookups so the output of an included rule set can be used as the key
   for a lookup. In some examples, the order of evaluation is more flexible and the
35 ordering of lookups vs. evaluation of included rule sets can be automatically
                                                29

   WO 2008/124319                                                            PCT/US2008/058360
 5 determeined based on a dependency analysis. Because included rule sets are evaluated
   before any output variables are computed, no output variables in the including rule set
   can be mapped to inputs in the included rule set. If the mapping to an included rule set
   input cannot be done with a simple input variable, an expression can be used instead.
   [0107] The mapping to an included rule set input variable can be NULL, as long as
10 input variable in the included rule set is nullable. The mapping can also be left blank.
   If the mapping is left blank, then an error will be reported at transform generation
   time, if and only if that input variable is needed in the computation of the including
   rule set's outputs. In some examples, it is assumed that everything is nullable, which
   simplifies the user interface.
15 [0108] In the context of the including rule set, the output variables of the shared rule
   set also need to be mapped to business names in the including rule set. This mapping
   table is the reverse of the one above. When mapping a shared rule set's input
   variables, the table maps the business name of the shared rule set's input variable to
   an existing variable in the including rule set. But when mapping the shared rule set's
20 output variables, the including rule set has a table that specifies a business name for
   the outputs of the shared rule sets - mapping names in the including rule set to the
   corresponding names in the shared rule set.
   [0109] The output variable mapping is needed to resolve potential naming conflicts.
   The default mapping is to simply use the same business names in both the including
25 rule set and in the shared rule set. But the names of output variables in the shared rule
   set may conflict with the business names of variables already defined in the including
   rule set, so the mapped named in the including rule set can be changed.
   [0110] Not every output from the shared rule set needs to be mapped. If an output is
   left unmapped, that output cannot be used in the including rule set, and the
30 corresponding logic from the shared rule set will be ignored. On the other hand, all of
   the inputs from the shared rule set should be mapped, although they can be mapped to
   uninteresting variables if the rule set designer is sure that they will not be needed. In
   some examples, the system itself may determine which inputs really need to be
   mapped.
                                                 30

   WO 2008/124319                                                             PCT/US2008/058360
 5 [0111] In some examples, the mapping table is done by business name, not by
   reference. When a shared rule set is included in another rule set, the including rule set
   gets a copy of the input and outputs from the shared rule set. These names are stored
   in the including rule set along with the mapping information. It is possible that the
   shared rule set gets changed, causing some inputs or outputs to be added, deleted or
10 renamed.
   [0112] Referential integrity problems between including and included rule sets can be
   handled by the including rule set when that rule set is loaded from the system. Input
   variables that disappear from the shared rule set are deleted from the including rule
   set. Input variables that get added to the shared rule set are added to the mapping table
15 in the including rule set, but remain unmapped. Likewise, output variables that get
   added to the shared rule set get added to the mapping table in the including rule set,
   but remain unmapped. If an output variable gets deleted from the shared rule set, and
   it is not used in the including rule set it is just deleted from the mapping table, but if it
   is used in the including rule set, the user gets an error that the variable is no longer
20 available.
   [0113] The including rule set actually persists redundant information from the shared
   rule sets. Specifically, in the input and output variable mapping table, the including
   rule set only needs to maintain a list of the business names in the shared rule set along
   with the corresponding named in the including rule set. For efficiency, the including
25 rule set also persists the type, default value, description and comment, all copied out
   of the shared rule set. These values are read/only when editing the including rule set
   but are included for efficiency for generation of reports and other analysis.
   [0114] The shared rule set mapping tables also have one additional entry in the
   included rule set, which is an additional comment. This allows users to add another
30 comment to the mapped value.
   Constants for Shared Rule Sets
   [0115] Included in the mapping table for included rule sets are the constants for the
   shared rule set's input and output variables. As with the variables themselves, the
   constants used by the shared rule set may have to be mapped. For input variables, the
35 shared rule set may internally compare field against constants, defined in its input
                                                   31

   WO 2008/124319                                                             PCT/US2008/058360
 5 table. When the shared rule set is included in another rule set, the constants for its
   input variables are copied over to the including rule set. The user can then override
   the values in the context of the including rule set. Usually, when the user defined a
   mapping between the shared rule set input variable and a variable in the including rule
   set, the constants between the two variables will match up. If this is not the case, the
10 user will need to supply a technical value for any constant value defined by the shared
   rule set.
   Lookup Files
   [0116] Rule sets can optionally have one or more lookup files. Each lookup file in a
   rule set includes the following information:
15          1. The Business name of the lookup file.
            2. An optional description and comment.
            3. A list of the business names for the fields that make up the key. These
                names are used when the lookup file is added to an expression so the user
                sees something like this: lookup(My Lookup File, <customer name key>,
20              <account type key>).
            4. A list of default expressions for each of the keys.
            5. The technical name of the lookup file. In some examples, this can be
                overridden in the deployment.
            6. One or more lookup datasets. Each lookup file is loosely tied to a dataset
25              within the system just like rule sets are tied to input datasets. By default,
                there is one lookup dataset associated with each lookup file in the rule set,
                but there can be more lookup datasets for use in alternate deployments.
            7. A table of input variables and constants. This is just like the table of input
                variables and constants for rule sets except that there is one table for each
30              lookup file. As with input variables, the table of input variables and
                constants for lookup files can have multiple technical names,
                corresponding to each of the associated lookup datasets.
   [0117] Lookup files are handled just like input variables, except that there may be
   more than one lookup file. Each lookup file is edited on one page, has a mapping table
                                                 32

   WO 2008/124319                                                            PCT/US2008/058360
 5 between business names and technical names and can be associated with multiple
   datasets. They also have constants associated with each field. The mapping for a
   lookup file can be initialized by reading the metadata for a lookup dataset just like the
   metadata for input variables is loaded form an input dataset.
   [0118] If a user uses a lookup field variable, and the key is not found in the lookup,
10 the value of the field is assumed to be null. Unless the rule case specifically triggers if
   the field is null, the rule case will evaluate as false and be skipped. In such a case, no
   error is generated. If a user uses a lookup file variable (the lookup file itself and not a
   field), then the function lookupmatch is assumed so the lookup file variable
   evaluates to true or false. Both cases apply to rule expressions for either input or
15 output columns. If a user uses a lookup field variable as an output variable default, a
   failure to find the lookup is translated into a NULL.
   Parameters
   [0119] A rule set may refer to parameters. In some examples, each rule set has an
   optional parameter table, which, like a variable table, maps the business names of
20 parameters to their technical names. Each entry in the parameter table has the
   following attributes:
            1. The business name. This is the name of the parameter, as it will appear in
                rule bodies. In general parameters can be used anywhere an input variable
                is used.
25          2. The technical name. This is the name of the parameter in the development
                environment.
            3. The type of the parameter (string, decimal, date or datetime). In the
                generated transform, parameters may be converted into other types as
                needed.
30          4. An optional description and comment.
                                                 33

   WO 2008/124319                                                            PCT/US2008/058360
 5 [0120] Parameters are like variables except that their values are constant across the
   entire input file, and their values are specified externally when processing starts.
   Testing Rules
   [0121] Part of generating or updating a transform is testing the rule to which it will
   correspond. Rules are also validated, that is, checked for syntax and semantic
10 consistency. In contrast to validation, testing involves execution of the rules and
   correctness is determined by the user, for example by providing expected output or
   comparing the output to expected values manually.
   [0122] The software supports testing at two levels. As described earlier, each rule may
   have an associated test dataset, in the form of an embedded table of values and
15 expected results. This is referred to as unit testing. When editing a rule, it is possible
   to re-evaluate the rule's outputs for each line of test data. Any mismatches between
   actual results and expected results or failures to produce valid results are highlighted
   for resolution.
   [0123] In some examples, external input test files are accessible to the server process
20 using standard mechanisms. Testing using external files is referred to as file testing. A
   test file has a record format that matches the input dataset for the rule set. In some
   examples, an alternate record format may be provided. Optionally, users can identify a
   dataset that contains expected results. The software runs the rule set against the test
   dataset and displays what outputs were produced, and why. If expected results were
25 included, the software compares the actual results against the expected results and
   lists any records that were different. In some examples, the interface can be extended
   to allow the user to incrementally retrain individual values.
   [0124] Some differences between unit testing and file testing include:
             1. For lookup files: in unit testing mode, for each test case, the value for each
30              lookup variable is defined as part of the test. No key is specified; when the
                test runs, the same value is assumed, for each test case, for each lookup
                variable. A test dataset contains multiple test cases, and each test case can
                specify a different value for each lookup variable. In file testing mode, real
                lookup files are used. This means that different keys will return different
                                                 34

   WO 2008/124319                                                              PCT/US2008/058360
 5              values, but it also means that the value used for any given lookup variable
                for a specific key cannot be changed during the test
            2. For included rule sets: in unit testing mode, included rule sets are not
                executed and do not even have to be complete. Instead, a value is specified
                in the test dataset for each output from each included rule set. In file
10              testing mode, included rule sets are executed the way they would be
                executed in production. This implies that any lookup files or parameters
                needed by the included rule sets also have to be specified at test time.
            3.  For parameters: in unit testing mode, a different value can be set for each
                parameter for each test case. In file testing mode, the value of each
15              parameter is constant for the entire test.
            4. For the current date: when testing, the user specifies the value that should
                be assumed for the current date and time, in case the rules refer to the
                current date or time. In unit testing mode, the date and time can be
                different for each test case. In file testing mode, a single date and time
20              value is set for the entire test (this value can be different that the date and
                time of the machine at the time the test is run).
            5. For record formats and mappings: no mapping needs to be specified for
                unit testing; the testing is done entirely based on the business names of
                variables. For file testing, all the variables are mapped to technical names
25              and the record format for inputs, outputs and lookups is specified.
   [0125] In the example output screen of figure 4A, a results table 410 is shown in
   which the output for each test case is displayed in a separate row 412i with columns
   413a-d showing the test case and the outputs calculated for each. When one row 412a
   is selected (shown in figure 4A by a dashed line), the input values 414a-414g from the
30 corresponding test case are shown in an input table 414. The outputs 416a-416c for
   that test case are shown in an output table 416. The outputs 416i shown in the table
   416 could be the expected outputs from the test case, the actual outputs computed, or
   both. Various interface cues can be used to inform the user about the status of the test.
   For example, icons 419 indicate that the output in rows 412b and 412d for test cases 2
35 and 4 have changed since the last time the rule set was tested. If there is no "default"
   rule to catch combinations of input values that don't match any other rule, test cases
                                                   35

   WO 2008/124319                                                            PCT/US2008/058360
 5 having such inputs produce a null output 418. If an input record is rejected with a
   processing error, such as division by zero, an error may be indicated in the same way.
   If more than one rule case is triggered by a test case, the number of triggered rule
   cases may be indicated (422). By interacting with one of the displayed outputs, for
   example, by clicking on it, the user can be taken to a screen that details how that
10 output was determined, as shown in figure 4B.
   [0126] In the example output screen of figure 4B, a table 430 displays a rule for a
   single test case 412 from figure 4A and indicates with a dark border each input criteria
   436i that was true in any rule case 434i. For example, in the sixth rule case 434f, the
   cells containing values for the third and fourth inputs 436c and 436d are highlighted
15 because the values 412f and 412g for these inputs in the test case 412 match the
   values in the rule case (class is not first or business, row is <=40). In practice, any of a
   variety of graphical techniques may be used to differentiate true and false cells, such
   as highlighting, colors, fonts, or borders. The first rule case in which all values are
   matched with the test case, rule case 434c, is indicated by a dashed border as the rule
20 case that triggered the rule and produced the output indicated in line 412b in figure
   4A. Displaying not only the triggered rule case 434c but also the other rule cases
   allows the user to quickly determine what rule cases applied and what changes would
   be needed to achieve a desired output. In some examples, multiple rule cases that
   could have been triggered (e.g., if higher ones had not been) can be indicated. The
25 output that would be generated by each rule case (if it were to have been triggered)
   can be shown in column 438. These features may assist, for example, in debugging
   the rule case.
   [0127] In some examples, the outputs of one rule set may be inputs to another rule
   set. How a given test case is evaluated by the rule sets in such a case may be shown
30 graphically as in figure 4C. The business rule that put the test case traveler from
   figures 4A and 4B in boarding group 2 is shown as a box 442 receiving inputs from
   the test case table 412 and providing outputs to the output table 416. In this example,
   a second business rule indicates that a traveler whose miles per year are increasing
   should be rewarded. That rule receives as input the determination from the first rule
35 that the miles are increasing, in addition to the inputs from the test case, and is shown
   as box 444. Because the flyer is in coach, this rule gives the customer free drinks. (If
                                                  36

   WO 2008/124319                                                            PCT/US2008/058360
 5 the customer were in first class, she would already receive free drinks, and a different
   reward would be in order.) In some examples, clicking on the displayed rules may
   take the user to the display of how that rule was triggered, as shown in figure 4B for
   the first rule 442.
   [0128] Rule sets are tested and validated using the process shown in figure 5. One or
10 more rule Sets 602 and corresponding test data 604 are the inputs to this process. The
   software generates a transform (606) based on the rule sets and uses it to compute
   output values for every record in the test data. In a graph computation, a "log" port of
   the relevant component is used for testing outputs. The transform generated for testing
   may be slightly different than the transform that would be generated for execution. At
15 test time, an additional output is added to the output record. This output is an array
   that contains identifications of rule sets that actually generated outputs and which rule
   cases within those rule sets were responsible for the outputs. Multiple outputs could
   be generated for each test case, i.e., different outputs from different rule sets. This
   array is used to generate the output tables shown in figure 4A and 4B, discussed
20 above. In some examples, the test output is more complex than a simple array. The
   output includes the value of every input for a given record, the value of every
   parameter, the value of every output from an included rule set and the value read from
   every lookup file (including indicating which key was used for the lookup).
   [0129] Beginning (608) with the first test case, the inputs of the test case are input
25 (610) into the transform, and the output is written (612) to the output array, together
   with an indication of which rule generated it. This process repeats for each row (614,
   616) until the last row has been evaluated (614). The output array can then be used to
   generate (617) the results tables 410 and 420 discussed above. The output array may
   be is evaluated to determine if the rule set is valid, as shown in the remaining steps in
30 figure 5. Output values may be included in the test data for the generated output
   values from one test may be compared to the values generated in a previous test.
   Beginning with the first row of the output array (618), the generated output is
   compared (620) to the expected output from the test data 604 or previous test results
   617. If any output does not match, the mismatch is logged (622). This repeats for each
35 row (624, 626). In some examples, the evaluation steps are integrated into the output
   generating steps, and each generated output is compared to the corresponding
                                                 37

   WO 2008/124319                                                            PCT/US2008/058360
 5 expected output as it is generated. Any mismatch or other error in processing the test
   data results is logged. As noted above, the outputs of one rule set may be inputs to
   another rule set, in which case the included rule set is evaluated as part of the
   including rule set.
   [0130] Users can limit the rules that are tested by output field. In some examples a
10 user can choose to disable a rule during testing. In some examples, users do not have
   to wait for the whole test file to be processed; test results are available as soon as the
   first few records work their way to the output.
   [0131] In addition to the test data itself, any of the following information may be
   used for file testing and can be included as part of the rule set:
15          1.  Physical Location of the input dataset. This is stored in the rule set in the
               input variables table for each input dataset. For join-type datasets, all the
               Physical Locations are needed. Whenever a physical location is needed, a
               table name in a database may be used.
            1.  Record format of the input dataset. By default, this is taken from the
20             dataset definition for the input dataset. There is a place in the input
               variables to override this with a different record format checked-out into
               the sandbox. For join-type transforms, all the record formats are needed.
            2.  Which deployment to use.
            3.  Physical Location for all lookup files. This is stored in the lookup files
25             table.
            4.  Record format for each lookup file. Taken from the dataset definition
               associated with each lookup file, or from an override record format file.
            5.  Value for each parameter. This will be set in a test parameters dialog.
            6.  Physical location for the output file. This is only needed when doing
30             regression (comparison) testing. It is stored in the output variables table.
            7.  Record format for the output file. Once again, only needed when doing
               regression testing, and taken from the output dataset definition or from an
               optional override record format file.
                                                38

   WO 2008/124319                                                             PCT/US2008/058360
 5          8.   Location of the project sandbox. Testing must be done out of a sandbox on
                the host. The sandbox should be a checked-out copy of the project that
                contains the rule set. All the record format files will be taken from the
                sandbox.
            9. Value to use for the date and time when a rule refers to "now," "today," or
10              similar values.
   [0132] There are three possible transform types: one with no logging, one with
   logging of all inputs, output, rules executed, etc., and one which additionally includes
   details about which cells in each rule are false or null. Testing can use either of the
   latter two types of logging. If the transform does not log cell state, this is simply not
15 shown in the user interface. Logging inputs, outputs, etc., slows down execution but
   only by a small amount. Logging cell state slows down execution a lot, perhaps by as
   much as an order of magnitude.
   [0133] When not testing, the user can still generate a transform that logs inputs,
   outputs, etc., and use that transform in production. The enhanced transform generates
20 the same outputs but also generates a series of log messages that can be analyzed,
   post-execution, to determine which rules were executed. If the user saves the logs
   generated, then the Business Rules Environment can be used after the fact to replay
   the execution of the rule set in production, by using the information in the log to
   compute the information in figures 4A, 4B and 4C, even though no testing input was
25 used. We call this execution playback and it is useful for auditing.
   Overlap Analysis
   [0134] In some examples, as mentioned above, when the user runs the test dataset
   against the rule set, every rule that triggered can be tracked, that is, rule cases that had
   all their input conditions met and would have produced output if a higher-priority rule
30 case had not also had all its input conditions met. After processing the test data, the
   software can post-process the test output data and generate a list of every rule or rule
   case that was not triggered by any of the test cases. This information can be overlaid
   on the display of rules in the editor to quickly show the user which rules were or were
   not triggered. From this information, the user can look for possible rules that are
35 obscured by other rules, that is, rules which overlap. Counts can also be shown for
                                                  39

   WO 2008/124319                                                            PCT/US2008/058360
 5 each rule case. Counts can be as useful as just knowing whether a rule case triggered,
   especially for tuning values to achieve a desired distributionj of outputs and for
   identifying the most likely rule cases for adjusting performance.
   Transform Generation
   [0135] Business rules are evaluated in an application (graph) by converting each rule
10 set into a transform. The transform is then attached to a component in a graph. Such
   components may be subgraphs that contain a set of standard components linked in a
   particular way to execute the transform. These subgraphs can then be used with
   additional components, for example to use keys for joins and rollups.
   [0136] Transform code can be generated from business rules in multiple ways. In
15 examples in which the internals of the transforms are not designed to be user-edited,
   the generation process can result in transforms that are difficult to comprehend, but
   which implement the rules more efficiently than applying the rules one-by-one. In
   some examples, as shown in figure 6, simple if-then-else chains 500 can be used to
   capture the logic in the rules sets (the rule set table 200 of figure 2A is repeated for
20 reference). In the chain 500 shown, there is one "if ... then ... " clause 502i for each
   rule case 210a. Such chains can be used as-is, or they can be further optimized
   depending on the availability of appropriate computing resources and the priorities of
   the users of the system. In some cases, specialized lookup files or other technologies
   may be used to improve performance of the generated transform. Some details of how
25 a transform is generated can be stored in a deployment. A rule set that may be used in
   multiple graphs may have multiple deployments for its different possible users. A rule
   set may also contain a super set of rules, only some of which are required in each
   deployment, with the deployment identifying which rules to use when the transform is
   generated.
30 [0137] In some examples, If the rule includes a column that is a decimal, and there is
   a large number of different values matched for that column, then we can improve the
   performance of the transform by writing a "switch" statement branching on the
   indicated column. For example, consider this rule:
                                                 40

   WO 2008/124319                                                           PCT/US2008/058360
 5
     Flight Number         Row of Seat         Boarding Group (output)
              1                <10                         1
              1                                            2
              2                <15                         1
              2                                            2
              3                                            1
              4                                            1
              5                <10                         1
              5                <20                         2
              5                                            3
   [0138] The transform for this rule could be generated in two ways. Like this:
   if (NUM == l and ROW < 10) then BG = 1
   else if (NUM == 1) then BG = 2
10 else if (NUM == 2 and ROW < 15) then BG         = 1
   else if (NUM ==2) then BG = 2
   else if ...
   Or like this:
15
   Switch (NUM)
     Case 1: if (ROW < 10) then BG= 1 else BG= 2
     Case 2: if (ROW < 15) then BG = 1 else BG = 2
20
   [0139] Another technique we can use is an in memory lookup file. If the rule has a
   lot of constant values, with few (if any) expressions, then instead of if then else logic,
   we can just use a lookup table. In this case, the lookup table is part of the rule (not
   saved separately). For example, consider this rule:
      From         Dest     Class of               expression               Frequent Flyer
       City        City      Service                                        Miles (output)
      BOS         LAX         First                                              6000
      BOS         LAX       Business                                             3000
      BOS         LAX        Coach           Is Using Miles  = yes                 0
      BOS         LAX        Coach                    else                       3000
      BOS          CHI        First                                              2000
      BOS          CHI       Coach                                               1000
      BOS         NYC         First                                              1500
      BOS         NYC       Business                                             1000
      BOS         NYC        Coach                                                500
25
                                                41

   WO 2008/124319                                                           PCT/US2008/058360
 5 [0140] This rule is handled by building an in-memory lookup table with the following
   information:
       from          dest       class      expr       miles
       BOS          LAX           1          0        6000
       BOS          LAX           2          0        3000
       BOS          LAX           3           1       3000
       BOS          CHI           1          0        2000
       BOS          CHI           2          0         1000
       BOS          NYC           1          0         1500
       BOS          NYC           2          0         1000
       BOS          NYC           3          0         500
   Then the transform is something like this:
10 int expr = lookup(from, dest, class).expr
   int miles = lookup(from, dest, class).miles
   if (expr == 1 and is_using miles) miles    = 0
   return miles;
15
   [0141] Each rule set has a deployment table. The deployment table maps a name to
   details about the configuration of that deployment. Each entry in the deployment table
   contains the following information:
            1.  Deployment name. An arbitrary string that must be unique within the rule
20             set.
           2.   Input dataset name. If there are multiple input datasets listed in the input
               variable table, then each entry in the deployment table indicates which
               input dataset is used for that deployment.
           3.   Output dataset name. If there are multiple output datasets listed in the
25             output variable table, then each entry in the deployment table indicates
               which output dataset is used for that deployment.
           4.   Deployment name for each included rule set. For each included rule set,
               we need to indicate which deployment should be used for each
               corresponding deployment of the including rule set.
30         5.   Target location for the component and the transform file to be generated.
   [0142] In some examples, there is always at least one deployment, named default.
   This is the deployment that is used when no other deployment is specified.
                                                42

   WO 2008/124319                                                             PCT/US2008/058360
 5 [0143] Here are the basics of transform generation, in one exemplary embodiment.
   First, the software will only generate rules for outputs that are computed in the rule
   set. All other outputs will be handled with a wildcard rule in the transform. In general,
   output variables that are only used internally cause local variables to be created in the
   generated transform. That said, the generated transform may include more local
10 variables, as necessary, to avoid duplicated calculations (for example, if optimizing is
   for speed over space).
   [0144] Figure 7 shows how a rule set is evaluated within a generated transform. For
   each output (702), the relevant rules are evaluated in order. For rules that generate
   disjoint outputs, the transform generator decides on the order of evaluation of the
15 rules based on dependency analysis. Circularities are not allowed and are reported as
   errors. If two or more rules generate the same outputs, their order of execution is the
   same as the order that they are listed in, in the rule set. Within each rule (704), the
   rule cases are evaluated in order, top to bottom. For each rule case (706), the trigger
   columns of each rule may be evaluated (708) in an undefined order (e.g., the software
20 may not guarantee the order of evaluation within the single case of a rule). As soon as
   one rule case is found in which all the triggers are true (not zero/false and not null)
   (714), the corresponding output values are used (716). As long as rule cases evaluate
   false, the process continues (718, 712, 720, 722). If no rule triggers for a given output
   (720), the transform will explicitly set the output value to NULL or the default value
25 as appropriate (724).
   [0145] There are some transform differences depending on the transform type:
        *   Reformat - The input is called "in," and input variables may have technical
            names like "in.field." The output is called "out,' and output variables may
            have technical names like "out.field."
30      e   Join - The two inputs are called "M" and "inl." The output is called "out,"
            and the wildcard rule assumes that inO is copied to "out." All the parameters
            may be set when the component is generated. The rule set will have multiple
            sets of inputs, one for each input to the join. The rule set will also specify the
            join type, whether inputs should be de-duped, and the business name of the
35          fields used as the key to the join (in some examples, this must be present in
                                                 43

   WO 2008/124319                                                          PCT/US2008/058360
 5        each input set). Also, user may be allowed to specify an expression for each
          input that is used as an input filter.
       " Rollup - The input is called "in" and the output is called "out." In the case of a
          rollup-type rule set, the user is allowed to use the aggregation functions
          (which are not supported in other transform types). If the user creates an
10        output variable whose technical name is "input-select" or "outputselect,"
          then an "input select" and/or "output select" function is added to the
          transform with the logic of the rules that compute those outputs. The input of
          both of those functions is called "in" (even though output select usually
          names its parameter "out"). As in the join type, all the parameters may be set
15        when the component is generated.
       *  Filter - One of two predefined constants is output. The only output variable
          for a Filter-type transform is "select," of type component, which is non-zero
          and non-NULL to pass the output. In some examples, this is implemented as a
          reformat component in a subgraph.
20 [0146] Additional transform types may also be implemented:
       *  Scan - The scan function takes two inputs, named "temp" and "in" and
          produces an output named "out." Rules in the rule set may use fields both
          from the temp and the in records. This may be determined by the technical
          name for the input variables. (For example, the technical names may be set to
25        strings "temp.field" or "in.field.")
                   The record format for the transform's temporary variable ("temp")
          contains every output generated by the rule set. An initialize function is
          created automatically by the software to initialize every field in the temporary
          record format to their default values. A finalize function is also created
30        automatically by the software; this function simply copies the temporary
          record to the output and adds the wildcard rule. The scan-type transform also
          supports creating an inputselect function and an outputselect function, like
          the Rollup case, if variables with those technical names are in the output
          variables table.
35     e  Normalize - The normalize function takes two inputs, "in" and "index," and
          produces an output named "out." The index input is not a record, instead users
                                                 44

   WO 2008/124319                                                            PCT/US2008/058360
 5         create an input variable mapped to a technical name of index if they want to
           use the index in rules. (The index variable can also be used in the various
           DML expressions.) The software will a length as it goes through the rules as
           described earlier..
                    A normalize-type rule set also supports output variables named
10         "inputselect" and "output select," just like the rollup-type rule set.
       .   Classification -A rule has N outputs and the transform decides which output
           should be used for each record. For this component, the software creates a
           out::classify(in) function. The output is a single integer value, indicating
           which output port (there can be more than one) should be used. An output of 0
15         means the zeroth port, an output of 1 means the first port, etc.
                    The only output variable for a Classification-type transform is "select,"
           of type component, which will be the index of the output port (zero-based).
           This is similar to a filter except that N values are used instead of two for the
           output.
20     e   Function - A function-type rule set can be turned into a DML transform file,
           but not as a component transform. Instead, when a function-type rule set is
           turned into a transform, the constructed transform file is designed to be
           included in other transforms. Each output variable is turned into a DML
           function. The inputs for those functions depend on the type of rule. For a
25         function-type rule, the inputs are the inputs to the rule in the order listed in the
           table. For non-function-type rules, each output function takes a single input,
           named in, that is a record with all the fields corresponding to the input
           variables.
   [0147] When a rule set is used to generate a transform that will in turn be part of a
30 graph, the graph component includes the name of the rule set and a deployment. A
   graph developer can then edit the rule set instead of the generated transform in the
   component. Changes to the rule set cause the transform to be regenerated.
   [0148] Other features and variations may include generating reports about rules in use
   in a particular rule set, a more finely-grained permission models, for example,
35 allowing some users to edit rules but not add inputs. An intra-rule dependency tree
   could be implemented for each output. Rules or rule sets may have effective dates or
                                                 45

   WO 2008/124319                                                           PCT/US2008/058360
 5 expiration dates. A single input record may produce multiple outputs, for example, if
   multiple rules have their criteria satisfied, they all may operate instead of just the first
   one. Support for vector output may be provided. Users may be able to specify their
   own validation functions during editing, for example, to further protect or constrain
   business users.
10 [0149] The business rules management approach described above can be
   implemented using software for execution on a computer. For instance, the software
   forms procedures in one or more computer programs that execute on one or more
   programmed or programmable computer systems (which may be of various
   architectures such as distributed, client/server, or grid) each including at least one
15 processor, at least one data storage system (including volatile and non-volatile
   memory and/or storage elements), at least one input device or port, and at least one
   output device or port. The software may form one or more modules of a larger
   program, for example, that provides other services related to the design and
   configuration of computation graphs. The nodes and elements of the graph can be
20 implemented as data structures stored in a computer readable medium or other
   organized data conforming to a data model stored in a data repository.
   [0150] The software may be provided on a medium, such as a CD-ROM, readable by
   a general or special purpose programmable computer or delivered (encoded in a
   propagated signal) over a network to the computer where it is executed. All of the
25 functions may be performed on a special purpose computer, or using special-purpose
   hardware, such as coprocessors. The software may be implemented in a distributed
   manner in which different parts of the computation specified by the software are
   performed by different computers. Each such computer program is preferably stored
   on or downloaded to a storage media or device (e.g., solid state memory or media, or
30 magnetic or optical media) readable by a general or special purpose programmable
   computer, for configuring and operating the computer when the storage media or
   device is read by the computer system to perform the procedures described herein.
   The inventive system may also be considered to be implemented as a computer
   readable storage medium, configured with a computer program, where the storage
35 medium so configured causes a computer system to operate in a specific and
   predefined manner to perform the functions described herein.
                                                 46

   [0151] A number of embodiments of the invention have been described. Nevertheless, it
   will be understood that various modifications may be made without departing from the
   spirit and scope of the invention. For example, some of the steps described above may be
   order independent, and thus can be performed in an order different from that described.
 5 [0152] It is to be understood that the foregoing description is intended to illustrate and not
   to limit the scope of the invention, which is defined by the scope of the appended claims.
   For example, a number of the function steps described above may be
   performed in a different order without substantially affecting overall processing.
   Other embodiments are within the scope of the following claims.
10 [0153] Throughout this specification and the claims which follow, unless the context
   requires otherwise, the word "comprise", and variations such as "comprises" and
   "comprising", will be understood to imply the inclusion of a stated integer or step or group
   of integers or steps but not the exclusion of any other integer or step or group of integers or
   steps.
15 [0154] The reference to any prior art in this specification is not, and should not be taken as,
   an acknowledgement or any form of suggestion that the prior art forms part of the common
   general knowledge in Australia.
                                                  47

CLAIMS
1.      A method for managing one or more rules applied to data in a data storage system, the
method including:
        receiving, over an input device or port, data from the data storage system; and
        processing, with at least one processor, at least a portion of the received data
according to a rule specified by a plurality of portions of a rule specification, the processing
including
                displaying, in an editor interface, a plurality of portions of the rule
        specification,
                applying the rule to a plurality of records of the received data to obtain result
        information, and
                displaying, in the editor interface, at least a first portion of the result
        information in association with a first displayed portion of the rule specification, and
        at least a second portion of the result information in association with a second
        displayed portion of the rule specification different from the first displayed portion of
        the rule specification.
2.      The method of claim 1, wherein applying the rule includes applying the rule to input
values in the received data to generate output values.
3.      The method of claim 2, wherein displaying at least a first portion of the result
information includes displaying a result of a comparison of the generated output values with
other output values.
4.      The method of claim 3, wherein the other output values include reference output
values in the received data corresponding to the input values.
5.      The method of claim 1, the processing further including receiving information that
defines at least a portion of the rule specification from a user.
6.      The method of claim 5, wherein displaying at least a first portion of the result
information includes displaying validation information based on the result information as the
received information is being entered into the editor interface.
                                                  48

7.       The method of claim 1, wherein a portion of the rule specification includes one or
more rule cases, and at least one rule case defines a condition for each of one or more
potential inputs.
8.      The method of claim 7, wherein at least one rule case defines an output associated
with a result of evaluating a defined condition.
9.      The method of claim 7, wherein displaying at least a first portion of the result
information includes displaying an indication of triggered rule cases for which the rule case's
defined condition was satisfied for input values in the received data as the potential inputs.
10.     The method of claim 9, wherein displaying at least a first portion of the result
information includes displaying information about how a triggered rule case was triggered.
11.     The method of claim 10, further including displaying the information about how a
triggered rule case was triggered in response to user interaction with at least a portion of the
displayed result information.
12.     The method of claim 10, wherein the information about how a triggered rule case was
triggered includes input values in the received data rule used to evaluate a rule case's defined
condition.
13.     The method of claim 1, wherein displaying at least a first portion of the result
information in association with a first displayed portion of the rule specification includes
displaying the first displayed portion of the rule specification in a particular color.
14.     The method of claim 1, wherein the result information includes a computed output
resulting from applying the rule to one record.
15.     The method of claim 1, wherein the result information is based on a plurality of
computed outputs resulting from applying the rule to a plurality of records.
                                                49

16.     The method of claim 1, wherein the editor interface enables editing of the rule
specification and displaying results of re-applying a rule specified by at least a portion of the
edited rule specification.
17.     The method of claim 1, wherein the processing includes:
        receiving, in the editor interface, information that re-defines at least a portion of the
rule specification,
        re-applying the rule to one or more records of the received data to obtain updated
result information, and
        displaying, in the editor interface, the updated result information in association with a
particular displayed portion of the rule specification.
18.      Software stored on a computer-readable medium, for managing one or more rules
applied to data in a data storage system, the software including instructions for causing a
computing system to:
        receive, over an input device or port, data from the data storage system; and
        process, with at least one processor, at least a portion of the received data according to
a rule specified by a plurality of portions of a rule specification, the processing including
                displaying, in an editor interface, a plurality of portions of the rule
        specification,
                applying the rule to a plurality of records of the received data to obtain result
        information, and
                displaying, in the editor interface, at least a first portion of the result
        information in association with a first displayed portion of the rule specification, and
        at least a second portion of the result information in association with a second
        displayed portion of the rule specification different from the first displayed portion of
        the rule specification.
19.     A computing system for managing one or more rules applied to data in a data storage
system, the computing system including:
        an input device or port configured to receive data from the data storage system; and
        at least one processor configured to process at least a portion of the received data
according to a rule specified by a plurality of portions of a rule specification, the processing
including
                                                 50

                displaying, in an editor interface, a plurality of portions of the rule
        specification,
                applying the rule to a plurality of records of the received data to obtain result
        information, and
                displaying, in the editor interface, at least a first portion of the result
        information in association with a first displayed portion of the rule specification, and
        at least a second portion of the result information in association with a second
        displayed portion of the rule specification different from the first displayed portion of
        the rule specification.
20.     A computing system for managing one or more rules applied to data in a data storage
system, the computing system including:
        means for receiving data from the data storage system; and
        means for processing at least a portion of the received data according to a rule
specified by a plurality of portions of a rule specification, the processing including
                displaying, in an editor interface, a plurality of portions of the rule
        specification,
                applying the rule to a plurality of records of the received data to obtain result
        information, and
                displaying, in the editor interface, at least a first portion of the result
        information in association with a first displayed portion of the rule specification, and
        at least a second portion of the result information in association with a second
        displayed portion of the rule specification different from the first displayed portion of
        the rule specification.
21.     A method for managing one or more rules applied to data in a data storage system, the
method including:
        receiving, over an input device or port, data from the data storage system that includes
input values and reference output values corresponding to the input values; and
        processing, with at least one processor, at least a portion of the received data
according to a rule specified by a plurality of portions of a rule specification, the processing
including
                receiving, in an editor interface, information that defines a plurality of portions
        of the rule based on respective portions of the rule specification,
                                                 51

                applying the rule to the input values in the received data to generate output
        values,
                displaying, in the editor interface, a first count of a number of times a first
        portion of the rule was triggered when applying the rule, and a second count of a
        number of times a second portion of the rule was triggered when applying the rule,
        and
                providing an indication of comparison of the generated output values with the
        reference output values in the received data.
22.     The method of claim 21, wherein providing the indication includes displaying a result
of the comparison in the editor interface.
23.     The method of claim 22, wherein displaying the result includes displaying a portion of
the rule specification in a particular color.
24.     The method of claim 21, wherein a portion of the rule specification includes one or
more rule cases, and at least one rule case defines a condition for each of one or more
potential inputs.
25.      The method of claim 24, wherein at least one rule case defines an output associated
with a result of evaluating a defined condition.
26.     The method of claim 21, wherein the rule specification is stored in association with
the data from the data storage system.
27.     The method of claim 21, further including receiving input identifying the data from
the data storage system.
28.     The method of claim 21, wherein the reference output values include values
previously generated based on the input values.
29.     The method of claim 28, wherein the previously generated values include values
generated in a previous test of the rule specified by at least a portion of the rule specification.
                                                 52

30.     Software stored on a computer-readable medium, for managing one or more rules
applied to data in a data storage system, the software including instructions for causing a
computing system to:
        receive, over an input device or port, data from the data storage system that includes
input values and reference output values corresponding to the input values; and
        process, with at least one processor, at least a portion of the received data according to
a rule specified by at least a portion of a rule specification, the processing including
                receiving, in an editor interface, information that defines a plurality of portions
        of the rule based on respective portions of the rule specification,
                applying the rule to the input values in the received data to generate output
        values,
                displaying, in the editor interface, a first count of a number of times a first
        portion of the rule was triggered when applying the rule, and a second count of a
        number of times a second portion of the rule was triggered when applying the rule,
        and
                providing an indication of comparison of the generated output values with the
        reference output values in the received data.
31.     A computing system for managing one or more rules applied to data in a data storage
system, the computing system including:
        an input device or port configured to receive data from the data storage system that
includes input values and reference output values corresponding to the input values; and
        at least one processor configured to process at least a portion of the received data
according to a rule specified by at least a portion of a rule specification, the processing
including
                receiving, in an editor interface, information that defines a plurality of portions
        of the rule based on respective portions of the rule specification,
                applying the rule to the input values in the received data to generate output
        values,
                displaying, in the editor interface, a first count of a number of times a first
        portion of the rule was triggered when applying the rule, and a second count of a
        number of times a second portion of the rule was triggered when applying the rule,
        and
                                                  53

                providing an indication of comparison of the generated output values with the
        reference output values in the received data.
32.     A computing system for managing one or more rules applied to data in a data storage
system, the computing system including:
        means for receiving data from the data storage system that includes input values and
reference output values corresponding to the input values; and
        means for processing at least a portion of the received data according to a rule
specified by at least a portion of a rule specification, the processing including
                receiving, in an editor interface, information that defines a plurality of portions
        of the rule based on respective portions of the rule specification,
                applying the rule to the input values in the received data to generate output
        values,
                displaying, in the editor interface, a first count of a number of times a first
        portion of the rule was triggered when applying the rule, and a second count of a
        number of times a second portion of the rule was triggered when applying the rule,
        and
                providing an indication of comparison of the generated output values with the
        reference output values in the received data.
33.     The software of claim 18, wherein applying the rule includes applying the rule to
input values in the received data to generate output values.
34.     The software of claim 33, wherein displaying at least a portion of the result
information includes displaying a result of a comparison of the generated output values with
other output values.
35.     The software of claim 34, wherein the other output values include reference output
values in the received data corresponding to the input values.
36.     The software of claim 18, the processing further including receiving information that
defines at least a portion of the rule specification from a user.
                                                  54

37.     The software of claim 36, wherein displaying at least a portion of the result
information includes displaying validation information based on the result information as the
received information is being entered into the editor interface.
38.     The software of claim 18, wherein a portion of the rule specification includes one or
more rule cases, and at least one rule case defines a condition for each of one or more
potential inputs.
39.     The software of claim 38, wherein at least one rule case defines an output associated
with a result of evaluating a defined condition.
40.     The software of claim 38, wherein displaying at least a portion of the result
information includes displaying an indication of triggered rule cases for which the rule case's
defined condition was satisfied for input values in the received data as the potential inputs.
41.     The software of claim 40, wherein displaying at least a portion of the result
information includes displaying information about how a triggered rule case was triggered.
42.     The software of claim 41, the processing further including displaying the information
about how a triggered rule case was triggered in response to user interaction with at least a
portion of the displayed result information.
43.     The software of claim 41, wherein the information about how a triggered rule case
was triggered includes input values in the received data rule used to evaluate a rule case's
defined condition.
44.     The software of claim 18, wherein displaying at least a portion of the result
information in association with a particular displayed portion of the rule specification
includes displaying the particular displayed portion of the rule specification in a particular
color.
45.     The software of claim 18, wherein the result information includes a computed output
resulting from applying the rule to one record.
                                                55

46.      The software of claim 18, wherein the result information is based on a plurality of
computed outputs resulting from applying the rule to a plurality of records.
47.      The software of claim 18, wherein the editor interface enables editing of the rule
specification and displaying results of re-applying a rule specified by at least a portion of the
edited rule specification.
48.      The software of claim 18, wherein the processing includes:
         receiving, in the editor interface, information that re-defines at least a portion of the
rule specification,
         re-applying the rule to one or more records of the received data to obtain updated
result information, and
         displaying, in the editor interface, the updated result information in association with a
particular displayed portion of the rule specification.
49.      The computing system of claim 19, wherein applying the rule includes applying the
rule to input values in the received data to generate output values.
50.      The computing system of claim 49, wherein displaying at least a portion of the result
information includes displaying a result of a comparison of the generated output values with
other output values.
51.      The computing system of claim 50, wherein the other output values include reference
output values in the received data corresponding to the input values.
52.      The computing system of claim 19, the processing further including receiving
information that defines at least a portion of the rule specification from a user.
53.      The computing system of claim 52, wherein displaying at least a portion of the result
information includes displaying validation information based on the result information as the
received information is being entered into the editor interface.
                                                  56

54.      The computing system of claim 19, wherein a portion of the rule specification
includes one or more rule cases, and at least one rule case defines a condition for each of one
or more potential inputs.
55.      The computing system of claim 54, wherein at least one rule case defines an output
associated with a result of evaluating a defined condition.
56.      The computing system of claim 54, wherein displaying at least a portion of the result
information includes displaying an indication of triggered rule cases for which the rule case's
defined condition was satisfied for input values in the received data as the potential inputs.
57.      The computing system of claim 56, wherein displaying at least a portion of the result
information includes displaying information about how a triggered rule case was triggered.
58.      The computing system of claim 57, the processing further including displaying the
information about how a triggered rule case was triggered in response to user interaction with
at least a portion of the displayed result information.
59.      The computing system of claim 57, wherein the information about how a triggered
rule case was triggered includes input values in the received data rule used to evaluate a rule
case's defined condition.
60.      The computing system of claim 19, wherein displaying at least a portion of the result
information in association with a particular displayed portion of the rule specification
includes displaying the particular displayed portion of the rule specification in a particular
color.
61.      The computing system of claim 19, wherein the result information includes a
computed output resulting from applying the rule to one record.
62.      The computing system of claim 19, wherein the result information is based on a
plurality of computed outputs resulting from applying the rule to a plurality of records.
                                                 57

63.     The computing system of claim 19, wherein the editor interface enables editing of the
rule specification and displaying results of re-applying a rule specified by at least a portion of
the edited rule specification.
64.     The computing system of claim 19, wherein the processing includes:
        receiving, in the editor interface, information that re-defines at least a portion of the
rule specification,
        re-applying the rule to one or more records of the received data to obtain updated
result information, and
        displaying, in the editor interface, the updated result information in association with a
particular displayed portion of the rule specification.
65.     The software of claim 30, wherein providing the indication includes displaying a
result of the comparison in the editor interface.
66.     The software of claim 65, wherein displaying the result includes displaying a portion
of the rule specification in a particular color.
67.     The software of claim 30, wherein a portion of the rule specification includes one or
more rule cases, and at least one rule case defines a condition for each of one or more
potential inputs.
68.     The software of claim 67, wherein at least one rule case defines an output associated
with a result of evaluating a defined condition.
69.     The software of claim 30, wherein the rule specification is stored in association with
the data from the data storage system.
70.     The software of claim 30, further including instructions for causing the computing
system to receive input identifying the data from the data storage system.
71.     The software of claim 30, wherein the reference output values include values
previously generated based on the input values.
                                                 58

72.      The software of claim 71, wherein the previously generated values include values
generated in a previous test of the rule specified by at least a portion of the rule specification.
73.      The computing system of claim 31, wherein providing the indication includes
displaying a result of the comparison in the editor interface.
74.      The computing system of claim 73, wherein displaying the result includes displaying
a portion of the rule specification in a particular color.
75.      The computing system of claim 31, wherein a portion of the rule specification
includes one or more rule cases, and at least one rule case defines a condition for each of one
or more potential inputs.
76.      The computing system of claim 75, wherein at least one rule case defines an output
associated with a result of evaluating a defined condition.
77.      The computing system of claim 31, wherein the rule specification is stored in
association with the data from the data storage system.
78.      The computing system of claim 31, the input device or port further configured to
receive input identifying the data from the data storage system.
79.      The computing system of claim 31, wherein the reference output values include
values previously generated based on the input values.
80.      The computing system of claim 79, wherein the previously generated values include
values generated in a previous test of the rule specified by at least a portion of the rule
specification.
81.      The method of claim 1, wherein the result information is based on whether or not at
least a portion of the rule was triggered when applying the rule to a plurality of records.
                                                 59

82.      The method of claim 1, wherein the result information is based on a count of a
number of times at least a portion of the rule was triggered when applying the rule to a
plurality of records.
83.      The software of claim 18, wherein the result information is based on whether or not at
least a portion of the rule was triggered when applying the rule to a plurality of records.
84.      The software of claim 18, wherein the result information is based on a count of a
number of times at least a portion of the rule was triggered when applying the rule to a
plurality of records.
85.      The computing system of claim 19, wherein the result information is based on
whether or not at least a portion of the rule was triggered when applying the rule to a plurality
of records.
86.      The computing system of claim 19, wherein the result information is based on a count
of a number of times at least a portion of the rule was triggered when applying the rule to a
plurality of records.
                                                60

<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
<removed-apn> <removed-date>
